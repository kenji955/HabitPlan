{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _detail, _detail2, _detail3, _detail4, _ref, _detail5, _detail6, _detail7, _detail8;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { createSlice } from \"@reduxjs/toolkit\";\nvar initialState = {\n  userTaskInfo: {\n    calendar: _defineProperty({}, new Date(\"Thu, 22 Oct 2020 02:00:00\").getFullYear(), _defineProperty({}, new Date(\"Thu, 22 Oct 2020 02:00:00\").getMonth() + 1, (_ref = {}, _defineProperty(_ref, new Date(\"Thu, 22 Oct 2020 02:00:00\").getDate(), {\n      PatternId: 1,\n      tasks: [{\n        order: 1,\n        detail: (_detail = {}, _defineProperty(_detail, \"タスク名\", \"タスク名 22 1\"), _defineProperty(_detail, \"testDetail1\", \"testDetail1 22 1\"), _defineProperty(_detail, \"testDetail2\", \"testDetail1 22 1\"), _detail),\n        flug: false\n      }, {\n        order: 2,\n        detail: (_detail2 = {}, _defineProperty(_detail2, \"タスク名\", \"タスク名 22 2\"), _defineProperty(_detail2, \"testDetail1\", \"testDetail1 22 2\"), _defineProperty(_detail2, \"testDetail2\", \"testDetail1 22 2\"), _detail2),\n        flug: false\n      }]\n    }), _defineProperty(_ref, new Date(\"Thu, 23 Oct 2020 02:00:00\").getDate(), {\n      PatternId: 1,\n      tasks: [{\n        order: 1,\n        detail: (_detail3 = {}, _defineProperty(_detail3, \"タスク名\", \"タスク名 23 1\"), _defineProperty(_detail3, \"testDetail1\", \"testDetail1 23 1\"), _defineProperty(_detail3, \"testDetail2\", \"testDetail1 23 1\"), _detail3),\n        flug: false\n      }, {\n        order: 2,\n        detail: (_detail4 = {}, _defineProperty(_detail4, \"タスク名\", \"タスク名 23 2\"), _defineProperty(_detail4, \"testDetail1\", \"testDetail1 23 2\"), _defineProperty(_detail4, \"testDetail2\", \"testDetail1 23 2\"), _detail4),\n        flug: false\n      }]\n    }), _ref))),\n    pattern: [{\n      patternId: 1,\n      patternName: \"testPattern1\"\n    }, {\n      patternId: 2,\n      patternName: \"testPattern2\"\n    }],\n    tasks: [{\n      detail: (_detail5 = {}, _defineProperty(_detail5, \"タスク名\", \"タスク名 22 1\"), _defineProperty(_detail5, \"defalut\", \"defalut\"), _defineProperty(_detail5, \"testDetail1\", \"testDetail1 22 1\"), _defineProperty(_detail5, \"testDetail2\", \"testDetail1 22 1\"), _detail5),\n      patternInfo: [{\n        patternID: 1,\n        order: 1\n      }]\n    }, {\n      detail: (_detail6 = {}, _defineProperty(_detail6, \"タスク名\", \"タスク名 22 2\"), _defineProperty(_detail6, \"defalut\", \"defalut\"), _defineProperty(_detail6, \"testDetail1\", \"testDetail1 22 2\"), _defineProperty(_detail6, \"testDetail2\", \"testDetail1 22 2\"), _detail6),\n      patternInfo: [{\n        patternID: 1,\n        order: 2\n      }]\n    }, {\n      detail: (_detail7 = {}, _defineProperty(_detail7, \"タスク名\", \"タスク名 23 1\"), _defineProperty(_detail7, \"defalut\", \"defalut\"), _defineProperty(_detail7, \"testDetail1\", \"testDetail1 23 1\"), _defineProperty(_detail7, \"testDetail2\", \"testDetail1 23 1\"), _detail7),\n      patternInfo: [{\n        patternID: 2,\n        order: 1\n      }, {\n        patternID: 1,\n        order: 3\n      }]\n    }, {\n      detail: (_detail8 = {}, _defineProperty(_detail8, \"タスク名\", \"タスク名 23 2\"), _defineProperty(_detail8, \"defalut\", \"defalut\"), _defineProperty(_detail8, \"testDetail2\", \"testDetail1 23 2\"), _defineProperty(_detail8, \"testDetail1\", \"testDetail1 23 2\"), _detail8),\n      patternInfo: [{\n        patternID: 2,\n        order: 2\n      }]\n    }]\n  }\n}; // const diff = (olds: any[], nexts: any[]) => ({\n//     adds: nexts.filter((e) => !olds.includes(e)),\n//     subs: olds.filter((e) => !nexts.includes(e)),\n// });\n// パターン更新時に未来に設定されているパターンの内容を更新する。\n// 更新対象はstate.calendar.tasks\n// 年月日が未来であり、かつ、パターンIDが同じものを対象に新しいパターンを登録する。\n\nvar futurePatternUpdate = function futurePatternUpdate(state, updatePatternId) {\n  console.log(\"====futurePatternUpdateここから====\");\n  console.log(Object.keys(state.userTaskInfo.calendar));\n  var today = new Date();\n  var nowYear = today.getFullYear();\n  var nowMonth = today.getMonth() + 1;\n  var nowDate = today.getDate();\n  var choicePatternTasks = state.userTaskInfo.tasks.filter(function (task) {\n    return task.patternInfo.some(function (task) {\n      return task.patternID == updatePatternId;\n    });\n  }); // パターンIDに紐付くタスク一覧からカレンダーへの登録情報を抽出する。\n\n  var updateTasks = choicePatternTasks.map(function (task) {\n    // パターンが複数登録されているタスクへの対応として、選択されているパターンIDに該当する要素だけを抽出する。\n    var taskPattern = task.patternInfo.filter(function (patternInfo) {\n      return patternInfo.patternID == updatePatternId;\n    }); // 配列のタスクと抽出したパターン情報を整形して返す。\n\n    return {\n      order: taskPattern[0].order,\n      detail: task.detail,\n      // detail2: task.detail2,\n      flug: false\n    };\n  });\n\n  var keyMonthList = function keyMonthList(keyYear) {\n    return Object.keys(state.userTaskInfo.calendar[parseInt(keyYear)]);\n  };\n\n  var keyDateList = function keyDateList(keyYear, keyMonth) {\n    return Object.keys(state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)]);\n  };\n\n  var dateTaskUpdate = function dateTaskUpdate(keyYear, keyMonth, keyDate) {\n    if (state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].PatternId == updatePatternId) {\n      state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks = updateTasks;\n      console.log(\"===dateTaskUpdate===\");\n      console.log(keyYear);\n      console.log(keyMonth);\n      console.log(keyDate);\n      console.log(updateTasks);\n    }\n  };\n\n  var diff = function diff(olds, nexts) {\n    return {\n      adds: nexts.filter(function (e) {\n        return !olds.includes(e);\n      }),\n      subs: olds.filter(function (e) {\n        return !nexts.includes(e);\n      })\n    };\n  }; // 登録されている年の連想配列のキーを全て取得\n\n\n  var keyYears = Object.keys(state.userTaskInfo.calendar);\n  keyYears.map(function (keyYear) {\n    if (parseInt(keyYear) == nowYear) {\n      // もし今年だったら、の処理\n      // 登録されている月の連想配列のキーを全て取得\n      var keyMonths = keyMonthList(keyYear);\n      keyMonths.map(function (keyMonth) {\n        if (parseInt(keyMonth) == nowMonth) {\n          // もし今月だったら\n          // 登録されている日の連想配列のキーを全て取得\n          var keyDates = keyDateList(keyYear, keyMonth);\n          keyDates.map(function (keyDate) {\n            if (parseInt(keyDate) > nowDate) {\n              // もし明日以降だったら登録内容を更新する\n              dateTaskUpdate(keyYear, keyMonth, keyDate);\n            } else if (parseInt(keyDate) == nowDate) {\n              // もし今日だったら、変更分だけ反映する。\n              // 処理未作成\n              var result = diff(state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks, updateTasks);\n              var updateArray = state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks.filter(function (task) {\n                return result.subs.some(function (sub) {\n                  return sub != task;\n                });\n              });\n              result.adds.map(function (add) {\n                updateArray.push(add);\n              });\n              state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks = updateArray;\n            }\n          });\n        } else if (parseInt(keyMonth) > nowMonth) {\n          // もし来月以降だったら、すべて更新する。\n          var _keyDates = keyDateList(keyYear, keyMonth);\n\n          _keyDates.map(function (keyDate) {\n            dateTaskUpdate(keyYear, keyMonth, keyDate);\n          });\n        }\n      });\n    } else if (parseInt(keyYear) > nowYear) {\n      // もし来年以降だったら、の処理。全て更新する。\n      var _keyMonths = keyMonthList(keyYear);\n\n      _keyMonths.map(function (keyMonth) {\n        var keyDates = keyDateList(keyYear, keyMonth);\n        keyDates.map(function (keyDate) {\n          dateTaskUpdate(keyYear, keyMonth, keyDate);\n        });\n      });\n    }\n  });\n  console.log(\"====futurePatternUpdateここまで====\");\n};\n\nvar tasksModule = createSlice({\n  name: \"tasks\",\n  initialState: initialState,\n  reducers: {\n    init: function init(state, action) {\n      var data = action.payload;\n      console.log(\"init data\");\n      console.log(data); // state = {...data};\n      // console.log(\"init state.userTaskInfo 前\");\n      // console.log(state.userTaskInfo);\n\n      state.userTaskInfo = data; // console.log(\"init state.userTaskInfo 後\");\n      // console.log(state.userTaskInfo);\n    },\n    Register: function Register(state, action) {\n      var data = action.payload;\n      state = _objectSpread(_objectSpread({}, state), data); // console.log('state');\n      // console.log(state);\n    },\n    allDelete: function allDelete(state) {\n      state = initialState;\n      console.log(\"check allDelete\");\n    },\n    // DayPlanにてタスクをクリックした際に完了フラグをtrueに変更する処理。引数にて年、月、日、タスクのインデックス番号を受け取っている。\n    taskCheckComplete: function taskCheckComplete(state, action) {\n      var index = state.userTaskInfo.calendar[action.payload[0]][action.payload[1]][action.payload[2]].tasks.findIndex(function (tasks) {\n        return tasks.order == action.payload[3];\n      });\n      console.log(index);\n      state.userTaskInfo.calendar[action.payload[0]][action.payload[1]][action.payload[2]].tasks[index].flug = !state.userTaskInfo.calendar[action.payload[0]][action.payload[1]][action.payload[2]].tasks[index].flug;\n    },\n    // 引数はstateと年、月、日、選択されているパターンIDの4つの数値が格納された配列\n    calendarPatternRegister: function calendarPatternRegister(state, action) {\n      // stateから選択されているパターンIDが設定されているタスクを抽出する。\n      var choicePatternTasks = state.userTaskInfo.tasks.filter(function (task) {\n        return task.patternInfo.some(function (task) {\n          return task.patternID == action.payload[3];\n        });\n      }); // パターンIDに紐付くタスク一覧からカレンダーへの登録情報を抽出する。\n\n      var TodayTasks = choicePatternTasks.map(function (task) {\n        // パターンが複数登録されているタスクへの対応として、選択されているパターンIDに該当する要素だけを抽出する。\n        var taskPattern = task.patternInfo.filter(function (patternInfo) {\n          return patternInfo.patternID == action.payload[3];\n        }); // 配列のタスクと抽出したパターン情報を整形して返す。\n\n        return {\n          order: taskPattern[0].order,\n          detail: task.detail,\n          // detail2: task.detail2,\n          flug: false\n        };\n      }); // ここに年がなかった時の処理を加える\n\n      if (action.payload[0] in state.userTaskInfo.calendar) {\n        // stateのMonthの連想配列に新しい日付の連想配列を追加する。\n        // 追加情報は引数の日とこれまでの処理で作成したカレンダー登録用情報\n        state.userTaskInfo.calendar[action.payload[0]][action.payload[1]] = _objectSpread(_objectSpread({}, state.userTaskInfo.calendar[action.payload[0]][action.payload[1]]), {}, _defineProperty({}, action.payload[2], {\n          PatternId: action.payload[3],\n          tasks: TodayTasks\n        }));\n      } else {\n        // stateのMonthの連想配列に新しい日付の連想配列を追加する。\n        // 追加情報は引数の日とこれまでの処理で作成したカレンダー登録用情報\n        state.userTaskInfo.calendar[action.payload[0]] = _objectSpread(_objectSpread({}, state.userTaskInfo.calendar[action.payload[0]]), {}, _defineProperty({}, action.payload[1], _defineProperty({}, action.payload[2], {\n          PatternId: action.payload[3],\n          tasks: TodayTasks\n        })));\n      } // action.payload[3];\n\n\n      console.log(state.userTaskInfo.calendar[action.payload[0]][action.payload[1]][action.payload[2]]);\n    },\n    // タスクの詳細を設定する処理。引数のテキスト配列には[入力内容、連想配列のキー、タスクの配列を指定する数字]が格納されている。\n    taskDetailRegister: function taskDetailRegister(state, action) {\n      state.userTaskInfo.tasks[parseInt(action.payload[2])].detail = _objectSpread(_objectSpread({}, state.userTaskInfo.tasks[parseInt(action.payload[2])].detail), {}, _defineProperty({}, action.payload[1], action.payload[0]));\n    },\n    // タスクを追加する処理。引数のテキスト配列には[入力内容、連想配列のキー、タスクの配列を指定する数字]が格納されている。\n    taskRegister: function taskRegister(state, action) {\n      var registerTask = action.payload;\n      registerTask.patternInfo.map(function (content) {\n        var choicePatternTasks = state.userTaskInfo.tasks.filter(function (task) {\n          return task.patternInfo.some(function (task) {\n            return task.patternID == content.patternID;\n          });\n        });\n        content.order = choicePatternTasks.length + 1;\n      });\n      console.log(registerTask);\n      state.userTaskInfo.tasks.push(registerTask);\n    },\n    // タスクのパターン登録状況を更新する。\n    taskPatternUpdate: function taskPatternUpdate(state, action) {\n      // ここでやることは？\n      // まず引数にタスクの配列インデックス番号が必要\n      // パターンIDの配列を受け取る。\n      // 配列とstateを比較して、なければ登録。Orderは最大値+1。逆に削除されているものは除外。\n      var statePatternIdList = state.userTaskInfo.tasks[action.payload.index].patternInfo.map(function (content) {\n        return content.patternID;\n      });\n      console.log('statePatternIdList');\n      console.log(statePatternIdList);\n\n      var diff = function diff(olds, nexts) {\n        return {\n          adds: nexts.filter(function (e) {\n            return !olds.includes(e);\n          }),\n          subs: olds.filter(function (e) {\n            return !nexts.includes(e);\n          })\n        };\n      };\n\n      var result = diff(statePatternIdList, action.payload.newChecked);\n      var updateArray;\n      console.log(result); // stateから削除対象を除外した配列を抽出する。\n\n      if (result.subs.length > 0) {\n        updateArray = state.userTaskInfo.tasks[action.payload.index].patternInfo.filter(function (content) {\n          // futurePatternUpdate(state,);\n          return result.subs.some(function (sub) {\n            return sub != content.patternID;\n          });\n        });\n      } else {\n        updateArray = state.userTaskInfo.tasks[action.payload.index].patternInfo;\n      }\n\n      console.log('1:updateArray');\n      console.log(updateArray); // \n\n      result.adds.map(function (add) {\n        var Max = 0; // 追加されたIDが設定されているタスクを抽出する。\n\n        var choicePatternTasks = state.userTaskInfo.tasks.filter(function (task) {\n          return task.patternInfo.some(function (taskPatternInfo) {\n            return taskPatternInfo.patternID == add;\n          });\n        }); // \n\n        choicePatternTasks.map(function (task) {\n          // 抽出された各タスクのパターンIDを比較し、最大値を取得する。\n          var content = task.patternInfo.find(function (info) {\n            return info.patternID == add;\n          });\n          Max < content.patternID ? Max = content.patternID : \"\";\n        });\n        var pushContent = {\n          patternID: add,\n          order: Max + 1\n        };\n        updateArray.push(pushContent);\n        futurePatternUpdate(state, add);\n      });\n      console.log('2:updateArray');\n      console.log(updateArray);\n      state.userTaskInfo.tasks[action.payload.index].patternInfo = updateArray;\n    },\n    // タスクを削除する処理。引数には削除対象タスクのインデックス番号が格納されている。\n    taskDelete: function taskDelete(state, action) {\n      // const deleteTask = state.userTaskInfo.tasks.splice(\n      //     action.payload,\n      //     1\n      // );\n      var deleteTask = state.userTaskInfo.tasks.filter(function (content, index) {\n        return index != action.payload;\n      });\n      console.log(deleteTask);\n      state.userTaskInfo.tasks = deleteTask;\n    },\n    // タスクをパターンから除外する処理。引数のオブジェクトにはパターンIDと削除対象タスクの名称が格納されている。\n    taskRemovePattern: function taskRemovePattern(state, action) {\n      var index = state.userTaskInfo.tasks.findIndex(function (content) {\n        return content.detail[\"タスク名\"] == action.payload.detailTitle;\n      });\n      var deletedTask = state.userTaskInfo.tasks[index].patternInfo.filter(function (content) {\n        return content.patternID != action.payload.patternId;\n      });\n      state.userTaskInfo.tasks[index].patternInfo = deletedTask;\n      console.log(deletedTask); // futurePatternUpdate(state);\n    },\n    // パターンを追加する処理。引数にはパターン名称が格納されている。\n    patternRegister: function patternRegister(state, action) {\n      var MaxId = 0;\n      state.userTaskInfo.pattern.map(function (patternContent) {\n        patternContent.patternId > MaxId ? MaxId = patternContent.patternId : '';\n      });\n      var addPattern = {\n        patternId: MaxId + 1,\n        patternName: action.payload\n      };\n      state.userTaskInfo.pattern.push(addPattern);\n    },\n    // パターンを削除する処理。引数にはパターンIDが格納されている。\n    patternDelete: function patternDelete(state, action) {\n      var updatePatternList = state.userTaskInfo.pattern.filter(function (patternContent) {\n        // console.log(patternContent.patternId);\n        // console.log(action.payload);\n        return patternContent.patternId != action.payload;\n      });\n      console.log(updatePatternList);\n      state.userTaskInfo.pattern = updatePatternList; // タスクとカレンダーに保管されているパターンを全て削除する必要がある\n      // カレンダーは未来分だけ\n      // state.userTaskInfo.tasksに保管されているパターン情報を削除する。\n\n      var updateTaskList = state.userTaskInfo.tasks.map(function (task) {\n        var updatePatternInfo = task.patternInfo.filter(function (taskPatternInfo) {\n          return taskPatternInfo.patternID != action.payload;\n        });\n        var updateTask = {\n          detail: task.detail,\n          patternInfo: updatePatternInfo\n        };\n        return updateTask;\n      });\n      console.log('after:updateTaskList');\n      console.log(updateTaskList);\n      state.userTaskInfo.tasks = updateTaskList; // state.userTaskInfo.calendarの未来分に保管されているパターン情報を削除する。\n\n      var today = new Date();\n      var nowYear = today.getFullYear();\n      var nowMonth = today.getMonth() + 1;\n      var nowDate = today.getDate();\n      var updateCalendarList = state.userTaskInfo.calendar;\n      var keyYears = Object.keys(state.userTaskInfo.calendar);\n      keyYears.map(function (year) {\n        if (parseInt(year) > nowYear) {// 対象が来年以降である場合、削除する。\n        } else if (parseInt(year) == nowYear) {\n          var keyMonth = Object.keys(state.userTaskInfo.calendar[parseInt(year)]); // 対象が今年である場合\n\n          keyMonth.map(function (month) {\n            if (parseInt(month) > nowMonth) {// 来月以降の場合、削除する。\n            } else if (parseInt(month) == nowMonth) {\n              // 今月の場合\n              var keyDate = Object.keys(state.userTaskInfo.calendar[parseInt(year)][parseInt(month)]);\n              keyDate.map(function (date) {\n                if (parseInt(date) > nowDate) {// 明日以降の場合、削除する\n                }\n              });\n            }\n          });\n        }\n      });\n    },\n    // パターン名称を編集する処理。引数にはパターンIDとパターン名称が格納されている。\n    patternNameEdit: function patternNameEdit(state, action) {\n      // IDに合致する要素のインデックス番号を取得\n      var editPatternIndex = state.userTaskInfo.pattern.findIndex(function (patternContent) {\n        return patternContent.patternId == action.payload.editPatternId;\n      }); // 取得したインデックス番号を目印に、引数の新しい名称で更新する。\n\n      state.userTaskInfo.pattern[editPatternIndex].patternName = action.payload.patternName;\n    }\n  }\n});\nvar _tasksModule$actions = tasksModule.actions,\n    init = _tasksModule$actions.init,\n    Register = _tasksModule$actions.Register,\n    allDelete = _tasksModule$actions.allDelete,\n    taskCheckComplete = _tasksModule$actions.taskCheckComplete,\n    calendarPatternRegister = _tasksModule$actions.calendarPatternRegister,\n    taskDetailRegister = _tasksModule$actions.taskDetailRegister,\n    taskRegister = _tasksModule$actions.taskRegister,\n    taskPatternUpdate = _tasksModule$actions.taskPatternUpdate,\n    taskDelete = _tasksModule$actions.taskDelete,\n    taskRemovePattern = _tasksModule$actions.taskRemovePattern,\n    patternRegister = _tasksModule$actions.patternRegister,\n    patternDelete = _tasksModule$actions.patternDelete,\n    patternNameEdit = _tasksModule$actions.patternNameEdit;\nexport { init, Register, allDelete, taskCheckComplete, calendarPatternRegister, taskDetailRegister, taskRegister, taskPatternUpdate, taskDelete, taskRemovePattern, patternRegister, patternDelete, patternNameEdit };\nexport default tasksModule;","map":null,"metadata":{},"sourceType":"module"}