{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// データベースへの接続\n// import firebase from \"firebase/app\";\n// 認証周りやDB周りで必要なためimportしておく\nimport \"firebase/auth\";\nimport \"firebase/database\";\nimport { useMemo, useState, useEffect, useCallback } from \"react\";\nimport { firebase } from './firebaseTest'; // カスタムフックにしておく\n\nconst useDatabase = () => {\n  // 同じパスでは毎回同じ結果が得られるのでmemo化しておく\n  return useMemo(() => firebase.database().ref(\"/sample\"), []);\n}; //   データを取得する\n// hooksを使いたいのでカスタムhooksにしておく\n\n\nconst useFetchData = ref => {\n  const {\n    0: data,\n    1: setData\n  } = useState();\n  useEffect(() => {\n    // イベントリスナーを追加するにはonを使う\n    ref.on(\"value\", snapshot => {\n      // パスに対する全データを含むsnapshotが渡される\n      // ない場合はnullが変えるので存在をチェックしておく\n      if (snapshot === null || snapshot === void 0 ? void 0 : snapshot.val()) {\n        setData(snapshot.val());\n      }\n    });\n    return () => {\n      ref.off();\n    }; // refの変更に応じて再取得する\n    //   指定したパスのデータに対する更新をすべて検知するにはvalueを指定すれば良い。\n  }, [ref]); // データを返却する\n\n  return {\n    data\n  };\n}; // 実際に呼び出す際はこちらを使う\n\n\nexport const useFetchAllData = () => {\n  // refを取得して\n  const ref = useDatabase(); // ref渡してデータを取得する\n\n  return useFetchData(ref);\n}; // 登録処理\n// この登録はsetに渡した値での登録となる。\n// つまり、既存のデータも含めて渡してあげないと登録済みのデータが消える。\n\nconst useSetDocument = ref => {\n  const updateDocument = useCallback(document => {\n    // refについては前回の記事参照\n    // setに登録したいデータを渡してあげれば登録できる\n    ref.set(document);\n  }, [ref]);\n  return updateDocument;\n};\n\nexport const useRegisterData = () => {\n  // 前回作ったuseDatabase()を使いref取得\n  const ref = useDatabase();\n  const setDocument = useSetDocument(ref); // 登録済みのデータを全部取得する\n\n  const {\n    data: registeredData\n  } = useFetchAllData(); // データを登録する関数を返却する\n\n  const registerData = useCallback(registerData => {\n    // 既存のデータと登録するkey-valueを合わせて登録関数に渡す\n    setDocument(_objectSpread(_objectSpread({}, registeredData), registerData));\n  }, [setDocument, registeredData]); // 返した関数を利用することで、登録済みデータ全て+登録したいデータをDBに保管できる\n\n  return registerData;\n};\n\nconst useUpdateDocument = ref => {\n  // ref.updateがObjectを受け取るので、Objectを引数に取る関数を定義\n  const updateDocument = useCallback(document => ref.update(document), [ref]);\n  return updateDocument;\n}; // 更新処理\n\n\nexport const useUpdateData = () => {\n  // setの時と同じくrefを取得して、\n  const ref = useDatabase(); // 関数呼び出して\n\n  const updateDocument = useUpdateDocument(ref); // 更新処理を作成する\n\n  const updateData = useCallback(registerData => {\n    updateDocument(registerData);\n  }, [updateDocument]);\n  return updateData;\n}; // 削除処理\n\nconst useRemoveDocument = ref => {\n  // 特に引数が必要ないのでただ呼び出すのみ\n  const deleteDocument = useCallback(() => ref.remove(), [ref]);\n  return deleteDocument;\n}; // set、updateと同じなので割愛\n\n\nexport const useDelteData = () => {\n  const ref = useDatabase();\n  const removeDocument = useRemoveDocument(ref);\n  const deleteData = useCallback(() => removeDocument(), [removeDocument]);\n  return deleteData;\n};","map":{"version":3,"sources":["C:/Users/blelm/Desktop/AppCreate/habitPlan/src/components/test/firebaseTest/DBFetch.tsx"],"names":["useMemo","useState","useEffect","useCallback","firebase","useDatabase","database","ref","useFetchData","data","setData","on","snapshot","val","off","useFetchAllData","useSetDocument","updateDocument","document","set","useRegisterData","setDocument","registeredData","registerData","useUpdateDocument","update","useUpdateData","updateData","useRemoveDocument","deleteDocument","remove","useDelteData","removeDocument","deleteData"],"mappings":"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","sourcesContent":["// データベースへの接続\r\n\r\n// import firebase from \"firebase/app\";\r\n// 認証周りやDB周りで必要なためimportしておく\r\nimport \"firebase/auth\";\r\nimport \"firebase/database\";\r\nimport { useMemo, useState, useEffect, useCallback } from \"react\";\r\n\r\nimport {firebase} from './firebaseTest';\r\n\r\n\r\n// カスタムフックにしておく\r\nconst useDatabase = () => {\r\n    // 同じパスでは毎回同じ結果が得られるのでmemo化しておく\r\n    return useMemo(() => firebase.database().ref(\"/sample\"), []);\r\n};\r\n\r\n//   データを取得する\r\n// hooksを使いたいのでカスタムhooksにしておく\r\nconst useFetchData = (ref: firebase.database.Reference) => {\r\n    const [data, setData] = useState<{ [key: string]: string }>();\r\n    useEffect(() => {\r\n        // イベントリスナーを追加するにはonを使う\r\n        ref.on(\"value\", (snapshot:any) => {\r\n            // パスに対する全データを含むsnapshotが渡される\r\n            // ない場合はnullが変えるので存在をチェックしておく\r\n            if (snapshot?.val()) {\r\n                setData(snapshot.val());\r\n            }\r\n        });\r\n        return () => {\r\n            ref.off();\r\n        };\r\n        // refの変更に応じて再取得する\r\n        //   指定したパスのデータに対する更新をすべて検知するにはvalueを指定すれば良い。\r\n    }, [ref]);\r\n    // データを返却する\r\n    return { data };\r\n};\r\n\r\n// 実際に呼び出す際はこちらを使う\r\nexport const useFetchAllData = () => {\r\n    // refを取得して\r\n    const ref = useDatabase();\r\n    // ref渡してデータを取得する\r\n    return useFetchData(ref);\r\n};\r\n\r\n// 登録処理\r\n// この登録はsetに渡した値での登録となる。\r\n// つまり、既存のデータも含めて渡してあげないと登録済みのデータが消える。\r\nconst useSetDocument = (ref: firebase.database.Reference) => {\r\n    const updateDocument = useCallback(\r\n      (document: unknown) => {\r\n              // refについては前回の記事参照\r\n              // setに登録したいデータを渡してあげれば登録できる\r\n        ref.set(document);\r\n      }, [ref]\r\n    );\r\n    return updateDocument;\r\n  };\r\n  \r\n  export const useRegisterData = () => {\r\n      // 前回作ったuseDatabase()を使いref取得\r\n    const ref = useDatabase();\r\n    const setDocument = useSetDocument(ref);\r\n      // 登録済みのデータを全部取得する\r\n    const {data: registeredData} = useFetchAllData();\r\n  \r\n      // データを登録する関数を返却する\r\n    const registerData = useCallback((registerData: { [key: string]: string }) => {\r\n          // 既存のデータと登録するkey-valueを合わせて登録関数に渡す\r\n      setDocument({...registeredData, ...registerData});\r\n    }, [setDocument, registeredData]);\r\n  \r\n    // 返した関数を利用することで、登録済みデータ全て+登録したいデータをDBに保管できる\r\n    return registerData;\r\n  };\r\n\r\n  const useUpdateDocument = (ref: firebase.database.Reference) => {\r\n    // ref.updateがObjectを受け取るので、Objectを引数に取る関数を定義\r\n  const updateDocument = useCallback((document: Object) => ref.update(document), [ref]);\r\n  return updateDocument;\r\n}\r\n\r\n// 更新処理\r\nexport const useUpdateData = () => {\r\n  // setの時と同じくrefを取得して、\r\n    const ref = useDatabase();\r\n    // 関数呼び出して\r\n  const updateDocument = useUpdateDocument(ref);\r\n    // 更新処理を作成する\r\n  const updateData = useCallback((registerData: {[key: string]: string}) => {\r\n    updateDocument(registerData);\r\n  }, [updateDocument]);\r\n  return updateData;\r\n}\r\n\r\n// 削除処理\r\nconst useRemoveDocument = (ref: firebase.database.Reference) => {\r\n    // 特に引数が必要ないのでただ呼び出すのみ\r\n  const deleteDocument = useCallback(() => ref.remove(), [ref]);\r\n  return deleteDocument;\r\n}\r\n// set、updateと同じなので割愛\r\nexport const useDelteData = () => {\r\n  const ref = useDatabase();\r\n  const removeDocument = useRemoveDocument(ref);\r\n  const deleteData = useCallback(() => removeDocument(), [removeDocument])\r\n  return deleteData;\r\n}"]},"metadata":{},"sourceType":"module"}