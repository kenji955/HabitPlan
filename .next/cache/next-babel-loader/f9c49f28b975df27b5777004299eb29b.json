{"ast":null,"code":"// データベースへの接続\n// import firebase from \"firebase/app\";\n// 認証周りやDB周りで必要なためimportしておく\nimport \"firebase/auth\";\nimport \"firebase/database\";\nimport { useMemo, useState, useEffect, useCallback } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { firebase } from \"./firebaseTest\";\n\nconst useReduxFetch = () => {\n  const dispatch = useDispatch();\n  return dispatch;\n}; // カスタムフックにしておく\n\n\nconst useDatabase = () => {\n  // const useDatabase = () => {\n  const {\n    userId\n  } = useSelector(state => state.user); // const dispatch = useDispatch();\n  // const [check, setCheck] = useState(false);\n  // const [userIdCheck, setuserIdCheck] = useState('');\n  // if (userId != '' && userId != userIdCheck){\n  //     console.log('userId');\n  //     console.log(userId);\n  //     console.log('check');\n  //     console.log(check);\n  //     console.log('userIdCheck');\n  //     console.log(userIdCheck);\n  //     setuserIdCheck(userId);\n  //     setCheck(!check);\n  // }\n  // 同じパスでは毎回同じ結果が得られるのでmemo化しておく\n  // return useMemo(() => firebase.database().ref(\"/sample\"), []);\n  // const authUser = firebase.auth().currentUser;\n  // if (!!uid) {\n  //     if (userId == \"\") {\n  //         dispatch(login(uid.uid));\n  //         setCheck(\"check\");\n  //         // console.log(\"check\");\n  //     }\n  //     // console.log(\"DBF 1 userId\");\n  //     // console.log(userId);\n  //     return useMemo(() => firebase.database().ref(\"/users/\" + userId), [\n  //         userId,\n  //     ]);\n  // } else {\n  // ここが原因。ここでuserId取得後にrefを更新できればいい\n\n  console.log(\"DBF 2 userId\");\n  console.log(userId);\n  return useMemo(() => firebase.database().ref(\"/users/\" + userId), [userId]); // return useMemo(() => firebase.database().ref(\"/users/\" + authUser.uid), []);\n  // }\n}; //   データを取得する\n// hooksを使いたいのでカスタムhooksにしておく\n\n\nconst useFetchData = ref => {\n  const {\n    0: data,\n    1: setData\n  } = useState();\n  const {\n    userId\n  } = useSelector(state => state.user);\n  useEffect(() => {\n    if (!!userId) {\n      // イベントリスナーを追加するにはonを使う\n      ref.on(\"value\", snapshot => {\n        // パスに対する全データを含むsnapshotが渡される\n        // ない場合はnullが返るので存在をチェックしておく\n        if (snapshot === null || snapshot === void 0 ? void 0 : snapshot.val()) {\n          setData(snapshot.val());\n          console.log(\"DBF data\");\n          console.log(data);\n        }\n      });\n      console.log(\"DBFetch data==========\");\n      console.log(data);\n      return () => {\n        ref.off();\n      }; // refの変更に応じて再取得する\n      //   指定したパスのデータに対する更新をすべて検知するにはvalueを指定すれば良い。\n    }\n  }, [ref]); // データを返却する\n\n  return {\n    data\n  };\n}; // 実際に呼び出す際はこちらを使う\n\n\nconst useFetchAllData = () => {\n  const uid = firebase.auth().currentUser;\n  const {\n    userTaskInfo\n  } = useSelector(state => state.tasks); // refを取得して\n\n  const ref = useDatabase();\n  console.log('ref');\n  console.log(ref); // ref渡してデータを取得する\n\n  return useFetchData(ref);\n}; // 登録処理\n// この登録はsetに渡した値での登録となる。\n// つまり、既存のデータも含めて渡してあげないと登録済みのデータが消える。\n\n\nconst useSetDocument = ref => {\n  const updateDocument = useCallback(document => {\n    // refについては前回の記事参照\n    // setに登録したいデータを渡してあげれば登録できる\n    ref.set(document);\n  }, [ref]);\n  return updateDocument;\n};\n\nconst useRegisterData = () => {\n  // 前回作ったuseDatabase()を使いref取得\n  const ref = useDatabase();\n  const setDocument = useSetDocument(ref); // 登録済みのデータを全部取得する\n\n  const {\n    data: registeredData\n  } = useFetchAllData();\n  const {\n    userTaskInfo\n  } = useSelector(state => state.tasks); // データを登録する関数を返却する\n  // 可能であればここの処理はそのままにして、引数でsteteを更新する処理を先に行いたい\n\n  const registerData = useCallback(() => {\n    // () => {\n    // console.log(userTaskInfo);\n    // ここでReduxに保管しているstateを更新する？\n    // dispatch(Register({ ...registerData }));\n    // 既存のデータと登録するkey-valueを合わせて登録関数に渡す\n    // setDocument({ ...registeredData, ...registerData });\n    setDocument(userTaskInfo);\n  }, [setDocument, registeredData]); // 返した関数を利用することで、登録済みデータ全て+登録したいデータをDBに保管できる\n\n  return registerData;\n}; // 更新処理\n\n\nconst useUpdateDocument = ref => {\n  // ref.updateがObjectを受け取るので、Objectを引数に取る関数を定義\n  const updateDocument = useCallback(document => ref.update(document), [ref]);\n  return updateDocument;\n};\n\nconst useUpdateData = () => {\n  // setの時と同じくrefを取得して、\n  const ref = useDatabase(); // 関数呼び出して\n\n  const updateDocument = useUpdateDocument(ref); // 更新処理を作成する\n\n  const updateData = useCallback(registerData => {\n    updateDocument(registerData);\n  }, [updateDocument]);\n  return updateData;\n}; // 削除処理\n\n\nconst useRemoveDocument = ref => {\n  // 特に引数が必要ないのでただ呼び出すのみ\n  const deleteDocument = useCallback(document => ref.child(document).remove(), [ref]);\n  return deleteDocument;\n}; // set、updateと同じなので割愛\n\n\nconst useDelteData = () => {\n  const ref = useDatabase();\n  const removeDocument = useRemoveDocument(ref);\n  const deleteData = useCallback(deleteData => removeDocument(deleteData), [removeDocument]);\n  return deleteData;\n};\n\nexport { useFetchAllData, useRegisterData, useUpdateData, useDelteData };","map":{"version":3,"sources":["C:/Users/blelm/Desktop/AppCreate/habitPlan/src/components/test/firebaseTest/DBFetch.tsx"],"names":["useMemo","useState","useEffect","useCallback","useSelector","useDispatch","firebase","useReduxFetch","dispatch","useDatabase","userId","state","user","console","log","database","ref","useFetchData","data","setData","on","snapshot","val","off","useFetchAllData","uid","auth","currentUser","userTaskInfo","tasks","useSetDocument","updateDocument","document","set","useRegisterData","setDocument","registeredData","registerData","useUpdateDocument","update","useUpdateData","updateData","useRemoveDocument","deleteDocument","child","remove","useDelteData","removeDocument","deleteData"],"mappings":"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","sourcesContent":["// データベースへの接続\r\n\r\n// import firebase from \"firebase/app\";\r\n// 認証周りやDB周りで必要なためimportしておく\r\nimport \"firebase/auth\";\r\nimport \"firebase/database\";\r\nimport { useMemo, useState, useEffect, useCallback } from \"react\";\r\n\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\nimport { RootState } from \"../../../modules/rootReducer\";\r\nimport { Register } from \"../../../modules/tasksModule\";\r\n\r\nimport { firebase } from \"./firebaseTest\";\r\n\r\nimport {\r\n    calendar,\r\n    pattern,\r\n    tasks,\r\n    userTask,\r\n    userTaskInfo,\r\n} from \"../../../modules/userTasksType\";\r\nimport { useTabContext } from \"@material-ui/lab\";\r\nimport { login } from \"../../../modules/userModule\";\r\n\r\nconst useReduxFetch = () => {\r\n    const dispatch = useDispatch();\r\n    return dispatch;\r\n};\r\n\r\n// カスタムフックにしておく\r\nconst useDatabase = () => {\r\n    // const useDatabase = () => {\r\n    const { userId } = useSelector((state: RootState) => state.user);\r\n    // const dispatch = useDispatch();\r\n    // const [check, setCheck] = useState(false);\r\n    // const [userIdCheck, setuserIdCheck] = useState('');\r\n    // if (userId != '' && userId != userIdCheck){\r\n    //     console.log('userId');\r\n    //     console.log(userId);\r\n    //     console.log('check');\r\n    //     console.log(check);\r\n    //     console.log('userIdCheck');\r\n    //     console.log(userIdCheck);\r\n    //     setuserIdCheck(userId);\r\n    //     setCheck(!check);\r\n    // }\r\n        // 同じパスでは毎回同じ結果が得られるのでmemo化しておく\r\n        // return useMemo(() => firebase.database().ref(\"/sample\"), []);\r\n        // const authUser = firebase.auth().currentUser;\r\n        // if (!!uid) {\r\n        //     if (userId == \"\") {\r\n        //         dispatch(login(uid.uid));\r\n        //         setCheck(\"check\");\r\n        //         // console.log(\"check\");\r\n        //     }\r\n\r\n        //     // console.log(\"DBF 1 userId\");\r\n        //     // console.log(userId);\r\n        //     return useMemo(() => firebase.database().ref(\"/users/\" + userId), [\r\n        //         userId,\r\n        //     ]);\r\n        // } else {\r\n        // ここが原因。ここでuserId取得後にrefを更新できればいい\r\n        console.log(\"DBF 2 userId\");\r\n    console.log(userId);\r\n    return useMemo(() => firebase.database().ref(\"/users/\" + userId), [\r\n        userId,\r\n    ]);\r\n    // return useMemo(() => firebase.database().ref(\"/users/\" + authUser.uid), []);\r\n    // }\r\n};\r\n\r\n//   データを取得する\r\n// hooksを使いたいのでカスタムhooksにしておく\r\nconst useFetchData = (ref: firebase.database.Reference) => {\r\n    const [data, setData] = useState<userTaskInfo>();\r\n    const { userId } = useSelector((state: RootState) => state.user);\r\n    useEffect(() => {\r\n        if(!!userId){\r\n            // イベントリスナーを追加するにはonを使う\r\n            ref.on(\"value\", (snapshot: any) => {\r\n                // パスに対する全データを含むsnapshotが渡される\r\n                // ない場合はnullが返るので存在をチェックしておく\r\n                if (snapshot?.val()) {\r\n                    setData(snapshot.val());\r\n                    console.log(\"DBF data\");\r\n                    console.log(data);\r\n                }\r\n            });\r\n            console.log(\"DBFetch data==========\");\r\n            console.log(data);\r\n            return () => {\r\n                ref.off();\r\n            };\r\n            // refの変更に応じて再取得する\r\n            //   指定したパスのデータに対する更新をすべて検知するにはvalueを指定すれば良い。\r\n        }\r\n    }, [ref]);\r\n    // データを返却する\r\n    return { data };\r\n};\r\n\r\n// 実際に呼び出す際はこちらを使う\r\nconst useFetchAllData = () => {\r\n    const uid = firebase.auth().currentUser;\r\n    const { userTaskInfo } = useSelector((state: RootState) => state.tasks);\r\n    // refを取得して\r\n    const ref = useDatabase();\r\n    console.log('ref');\r\n    console.log(ref);\r\n    // ref渡してデータを取得する\r\n    return useFetchData(ref);\r\n};\r\n\r\n// 登録処理\r\n// この登録はsetに渡した値での登録となる。\r\n// つまり、既存のデータも含めて渡してあげないと登録済みのデータが消える。\r\nconst useSetDocument = (ref: firebase.database.Reference) => {\r\n    const updateDocument = useCallback(\r\n        (document: unknown) => {\r\n            // refについては前回の記事参照\r\n            // setに登録したいデータを渡してあげれば登録できる\r\n            ref.set(document);\r\n        },\r\n        [ref]\r\n    );\r\n    return updateDocument;\r\n};\r\n\r\nconst useRegisterData = () => {\r\n    // 前回作ったuseDatabase()を使いref取得\r\n    const ref = useDatabase();\r\n    const setDocument = useSetDocument(ref);\r\n    // 登録済みのデータを全部取得する\r\n    const { data: registeredData } = useFetchAllData();\r\n    const { userTaskInfo } = useSelector((state: RootState) => state.tasks);\r\n    // データを登録する関数を返却する\r\n\r\n    // 可能であればここの処理はそのままにして、引数でsteteを更新する処理を先に行いたい\r\n    const registerData = useCallback(\r\n        () => {\r\n            // () => {\r\n            // console.log(userTaskInfo);\r\n            // ここでReduxに保管しているstateを更新する？\r\n            // dispatch(Register({ ...registerData }));\r\n            // 既存のデータと登録するkey-valueを合わせて登録関数に渡す\r\n            // setDocument({ ...registeredData, ...registerData });\r\n            setDocument(userTaskInfo);\r\n        },\r\n        [setDocument, registeredData]\r\n    );\r\n\r\n    // 返した関数を利用することで、登録済みデータ全て+登録したいデータをDBに保管できる\r\n    return registerData;\r\n};\r\n\r\n// 更新処理\r\nconst useUpdateDocument = (ref: firebase.database.Reference) => {\r\n    // ref.updateがObjectを受け取るので、Objectを引数に取る関数を定義\r\n    const updateDocument = useCallback(\r\n        (document: Object) => ref.update(document),\r\n        [ref]\r\n    );\r\n    return updateDocument;\r\n};\r\n\r\nconst useUpdateData = () => {\r\n    // setの時と同じくrefを取得して、\r\n    const ref = useDatabase();\r\n    // 関数呼び出して\r\n    const updateDocument = useUpdateDocument(ref);\r\n    // 更新処理を作成する\r\n    const updateData = useCallback(\r\n        (registerData: { [key: string]: string }) => {\r\n            updateDocument(registerData);\r\n        },\r\n        [updateDocument]\r\n    );\r\n    return updateData;\r\n};\r\n\r\n// 削除処理\r\nconst useRemoveDocument = (ref: firebase.database.Reference) => {\r\n    // 特に引数が必要ないのでただ呼び出すのみ\r\n    const deleteDocument = useCallback(\r\n        (document: string) => ref.child(document).remove(),\r\n        [ref]\r\n    );\r\n    return deleteDocument;\r\n};\r\n// set、updateと同じなので割愛\r\nconst useDelteData = () => {\r\n    const ref = useDatabase();\r\n    const removeDocument = useRemoveDocument(ref);\r\n    const deleteData = useCallback(\r\n        (deleteData: string) => removeDocument(deleteData),\r\n        [removeDocument]\r\n    );\r\n    return deleteData;\r\n};\r\n\r\nexport { useFetchAllData, useRegisterData, useUpdateData, useDelteData };\r\n"]},"metadata":{},"sourceType":"module"}