{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { createSlice } from \"@reduxjs/toolkit\"; // import { Task } from '../Types'\n\nimport { useRegisterData } from \"../components/test/firebaseTest/DBFetch\";\nconst initialState = {\n  [\"test\"]: \"test\"\n}; // const registerData = useRegisterData();\n// const useDatabase = () => {\n//     // 同じパスでは毎回同じ結果が得られるのでmemo化しておく\n//     return useMemo(() => firebase.database().ref(\"/sample\"), []);\n// };\n// const useSetDocument = (ref: firebase.database.Reference) => {\n//     const updateDocument = useCallback(\n//         (document: unknown) => {\n//             // refについては前回の記事参照\n//             // setに登録したいデータを渡してあげれば登録できる\n//             ref.set(document);\n//         },\n//         [ref]\n//     );\n//     return updateDocument;\n// };\n// const useFetchData = (ref: firebase.database.Reference) => {\n//     const [data, setData] = useState<{ [key: string]: string }>();\n//     useEffect(() => {\n//         // イベントリスナーを追加するにはonを使う\n//         ref.on(\"value\", (snapshot: any) => {\n//             // パスに対する全データを含むsnapshotが渡される\n//             // ない場合はnullが変えるので存在をチェックしておく\n//             if (snapshot?.val()) {\n//                 setData(snapshot.val());\n//             }\n//         });\n//         return () => {\n//             ref.off();\n//         };\n//         // refの変更に応じて再取得する\n//         //   指定したパスのデータに対する更新をすべて検知するにはvalueを指定すれば良い。\n//     }, [ref]);\n//     // データを返却する\n//     return { data };\n// };\n// // 実際に呼び出す際はこちらを使う\n// export const useFetchAllData = () => {\n//     // refを取得して\n//     const ref = useDatabase();\n//     // ref渡してデータを取得する\n//     return useFetchData(ref);\n// };\n\nfunction TasksModuleCreate() {\n  const registerData = useRegisterData();\n  return createSlice({\n    name: \"tasks\",\n    initialState,\n    reducers: {\n      Register(state, action) {\n        // // 前回作ったuseDatabase()を使いref取得\n        // const ref = useDatabase();\n        // const setDocument = useSetDocument(ref);\n        // // 登録済みのデータを全部取得する\n        // const { data: registeredData } = useFetchAllData();\n        // // データを登録する関数を返却する\n        // const registerData = useCallback(\n        //     (registerData: State) => {\n        //         // 既存のデータと登録するkey-valueを合わせて登録関数に渡す\n        //         setDocument({ ...registeredData, ...registerData });\n        //         state = { ...registeredData, ...registerData };\n        //     },\n        //     [setDocument, registeredData]\n        // );\n        const data = action.payload;\n        state = _objectSpread(_objectSpread({}, state), data);\n        registerData(action.payload); // 返した関数を利用することで、登録済みデータ全て+登録したいデータをDBに保管できる\n        //   return registerData;\n      } // addTask(state: State, action: PayloadAction<string>) {\n      //     state.count++;\n      //     const newTask: Task = {\n      //         id: state.count,\n      //         title: action.payload,\n      //         done: false,\n      //     };\n      //     state.tasks = [newTask, ...state.tasks];\n      // },\n      // doneTask(state: State, action: PayloadAction<Task>) {\n      //     const task = state.tasks.find((t) => t.id === action.payload.id);\n      //     if (task) {\n      //         task.done = !task.done;\n      //     }\n      // },\n      // deleteTask(state: State, action: PayloadAction<Task>) {\n      //     state.tasks = state.tasks.filter((t) => t.id !== action.payload.id);\n      // },\n\n\n    }\n  });\n}\n\n;\nconst useTasksModule = TasksModuleCreate(); // export const { addTask, doneTask, deleteTask } = tasksModule.actions;\n\nexport const {\n  Register\n} = useTasksModule.actions;\nexport default useTasksModule;","map":{"version":3,"sources":["C:/Users/blelm/Desktop/AppCreate/habitPlan/src/modules/tasksModule.tsx"],"names":["createSlice","useRegisterData","initialState","TasksModuleCreate","registerData","name","reducers","Register","state","action","data","payload","useTasksModule","actions"],"mappings":";;;;;;AACA,SAASA,WAAT,QAA2C,kBAA3C,C,CACA;;AAGA,SACIC,eADJ,QAIO,yCAJP;AAUA,MAAMC,YAAmB,GAAG;AACxB,GAAC,MAAD,GAAU;AADc,CAA5B,C,CAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,iBAAT,GAA4B;AACxB,QAAMC,YAAY,GAAGH,eAAe,EAApC;AAEA,SAAOD,WAAW,CAAC;AACfK,IAAAA,IAAI,EAAE,OADS;AAEfH,IAAAA,YAFe;AAGfI,IAAAA,QAAQ,EAAE;AACNC,MAAAA,QAAQ,CAACC,KAAD,EAAeC,MAAf,EAA6C;AACjD;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,cAAMC,IAAI,GAAGD,MAAM,CAACE,OAApB;AAEAH,QAAAA,KAAK,mCAAQA,KAAR,GAAkBE,IAAlB,CAAL;AACAN,QAAAA,YAAY,CAACK,MAAM,CAACE,OAAR,CAAZ,CApBiD,CAsBjD;AACA;AACH,OAzBK,CA2BN;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA9CM;AAHK,GAAD,CAAlB;AAoDH;;AAAA;AAED,MAAMC,cAAc,GAAGT,iBAAiB,EAAxC,C,CAEA;;AACA,OAAO,MAAM;AAAEI,EAAAA;AAAF,IAAeK,cAAc,CAACC,OAApC;AAEP,eAAeD,cAAf","sourcesContent":["import { useCallback, useEffect, useMemo, useState } from \"react\";\r\nimport { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\r\n// import { Task } from '../Types'\r\n\r\nimport { firebase } from \"../components/test/firebaseTest/firebaseTest\";\r\nimport {\r\n    useRegisterData,\r\n    useUpdateData,\r\n    useDelteData,\r\n} from \"../components/test/firebaseTest/DBFetch\";\r\n\r\ntype State = {\r\n    [key: string]: string;\r\n};\r\n\r\nconst initialState: State = {\r\n    [\"test\"]: \"test\",\r\n};\r\n\r\n// const registerData = useRegisterData();\r\n\r\n// const useDatabase = () => {\r\n//     // 同じパスでは毎回同じ結果が得られるのでmemo化しておく\r\n//     return useMemo(() => firebase.database().ref(\"/sample\"), []);\r\n// };\r\n\r\n// const useSetDocument = (ref: firebase.database.Reference) => {\r\n//     const updateDocument = useCallback(\r\n//         (document: unknown) => {\r\n//             // refについては前回の記事参照\r\n//             // setに登録したいデータを渡してあげれば登録できる\r\n//             ref.set(document);\r\n//         },\r\n//         [ref]\r\n//     );\r\n//     return updateDocument;\r\n// };\r\n\r\n// const useFetchData = (ref: firebase.database.Reference) => {\r\n//     const [data, setData] = useState<{ [key: string]: string }>();\r\n//     useEffect(() => {\r\n//         // イベントリスナーを追加するにはonを使う\r\n//         ref.on(\"value\", (snapshot: any) => {\r\n//             // パスに対する全データを含むsnapshotが渡される\r\n//             // ない場合はnullが変えるので存在をチェックしておく\r\n//             if (snapshot?.val()) {\r\n//                 setData(snapshot.val());\r\n//             }\r\n//         });\r\n//         return () => {\r\n//             ref.off();\r\n//         };\r\n//         // refの変更に応じて再取得する\r\n//         //   指定したパスのデータに対する更新をすべて検知するにはvalueを指定すれば良い。\r\n//     }, [ref]);\r\n//     // データを返却する\r\n//     return { data };\r\n// };\r\n\r\n// // 実際に呼び出す際はこちらを使う\r\n// export const useFetchAllData = () => {\r\n//     // refを取得して\r\n//     const ref = useDatabase();\r\n//     // ref渡してデータを取得する\r\n//     return useFetchData(ref);\r\n// };\r\n\r\nfunction TasksModuleCreate(){\r\n    const registerData = useRegisterData();\r\n\r\n    return createSlice({\r\n        name: \"tasks\",\r\n        initialState,\r\n        reducers: {\r\n            Register(state: State, action: PayloadAction<State>) {\r\n                // // 前回作ったuseDatabase()を使いref取得\r\n                // const ref = useDatabase();\r\n                // const setDocument = useSetDocument(ref);\r\n                // // 登録済みのデータを全部取得する\r\n                // const { data: registeredData } = useFetchAllData();\r\n\r\n                // // データを登録する関数を返却する\r\n                // const registerData = useCallback(\r\n                //     (registerData: State) => {\r\n                //         // 既存のデータと登録するkey-valueを合わせて登録関数に渡す\r\n                //         setDocument({ ...registeredData, ...registerData });\r\n                //         state = { ...registeredData, ...registerData };\r\n                //     },\r\n                //     [setDocument, registeredData]\r\n                // );\r\n\r\n                const data = action.payload;\r\n\r\n                state = { ...state, ...data };\r\n                registerData(action.payload);\r\n\r\n                // 返した関数を利用することで、登録済みデータ全て+登録したいデータをDBに保管できる\r\n                //   return registerData;\r\n            },\r\n\r\n            // addTask(state: State, action: PayloadAction<string>) {\r\n            //     state.count++;\r\n\r\n            //     const newTask: Task = {\r\n            //         id: state.count,\r\n            //         title: action.payload,\r\n            //         done: false,\r\n            //     };\r\n\r\n            //     state.tasks = [newTask, ...state.tasks];\r\n            // },\r\n            // doneTask(state: State, action: PayloadAction<Task>) {\r\n            //     const task = state.tasks.find((t) => t.id === action.payload.id);\r\n            //     if (task) {\r\n            //         task.done = !task.done;\r\n            //     }\r\n            // },\r\n            // deleteTask(state: State, action: PayloadAction<Task>) {\r\n            //     state.tasks = state.tasks.filter((t) => t.id !== action.payload.id);\r\n            // },\r\n        },\r\n    });\r\n};\r\n\r\nconst useTasksModule = TasksModuleCreate();\r\n\r\n// export const { addTask, doneTask, deleteTask } = tasksModule.actions;\r\nexport const { Register } = useTasksModule.actions;\r\n\r\nexport default useTasksModule;\r\n"]},"metadata":{},"sourceType":"module"}