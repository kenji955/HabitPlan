{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { createSlice } from \"@reduxjs/toolkit\";\nconst initialState = {\n  userTaskInfo: {\n    calendar: {\n      [new Date(\"Thu, 22 Oct 2020 02:00:00\").getFullYear()]: {\n        [new Date(\"Thu, 22 Oct 2020 02:00:00\").getMonth() + 1]: {\n          [new Date(\"Thu, 22 Oct 2020 02:00:00\").getDate()]: {\n            PatternId: 1,\n            tasks: [{\n              order: 1,\n              detail: {\n                [\"title\"]: \"title 22 1\",\n                [\"testDetail1\"]: \"testDetail1 22 1\",\n                [\"testDetail2\"]: \"testDetail1 22 1\"\n              },\n              flug: false\n            }, {\n              order: 2,\n              detail: {\n                [\"title\"]: \"title 22 2\",\n                [\"testDetail1\"]: \"testDetail1 22 2\",\n                [\"testDetail2\"]: \"testDetail1 22 2\"\n              },\n              flug: false\n            }]\n          },\n          [new Date(\"Thu, 23 Oct 2020 02:00:00\").getDate()]: {\n            PatternId: 1,\n            tasks: [{\n              order: 1,\n              detail: {\n                [\"title\"]: \"title 23 1\",\n                [\"testDetail1\"]: \"testDetail1 23 1\",\n                [\"testDetail2\"]: \"testDetail1 23 1\"\n              },\n              flug: false\n            }, {\n              order: 2,\n              detail: {\n                [\"title\"]: \"title 23 2\",\n                [\"testDetail1\"]: \"testDetail1 23 2\",\n                [\"testDetail2\"]: \"testDetail1 23 2\"\n              },\n              flug: false\n            }]\n          }\n        }\n      }\n    },\n    pattern: [{\n      patternId: 1,\n      patternName: \"testPattern1\"\n    }, {\n      patternId: 2,\n      patternName: \"testPattern2\"\n    }],\n    tasks: [{\n      detail: {\n        [\"title\"]: \"title 22 1\",\n        [\"defalut\"]: \"defalut\",\n        [\"testDetail1\"]: \"testDetail1 22 1\",\n        [\"testDetail2\"]: \"testDetail1 22 1\"\n      },\n      patternInfo: [{\n        patternID: 1,\n        order: 1\n      }]\n    }, {\n      detail: {\n        [\"title\"]: \"title 22 2\",\n        [\"defalut\"]: \"defalut\",\n        [\"testDetail1\"]: \"testDetail1 22 2\",\n        [\"testDetail2\"]: \"testDetail1 22 2\"\n      },\n      patternInfo: [{\n        patternID: 1,\n        order: 2\n      }]\n    }, {\n      detail: {\n        [\"title\"]: \"title 23 1\",\n        [\"defalut\"]: \"defalut\",\n        [\"testDetail1\"]: \"testDetail1 23 1\",\n        [\"testDetail2\"]: \"testDetail1 23 1\"\n      },\n      patternInfo: [{\n        patternID: 2,\n        order: 1\n      }, {\n        patternID: 1,\n        order: 3\n      }]\n    }, {\n      detail: {\n        [\"title\"]: \"title 23 2\",\n        [\"defalut\"]: \"defalut\",\n        [\"testDetail2\"]: \"testDetail1 23 2\",\n        [\"testDetail1\"]: \"testDetail1 23 2\"\n      },\n      patternInfo: [{\n        patternID: 2,\n        order: 2\n      }]\n    }]\n  }\n};\n\nconst diff = (olds, nexts) => ({\n  adds: nexts.filter(e => !olds.includes(e)),\n  subs: olds.filter(e => !nexts.includes(e))\n}); // パターン更新時に未来に設定されているパターンの内容を更新する。\n// 更新対象はstate.calendar.tasks\n// 年月日が未来であり、かつ、パターンIDが同じものを対象に新しいパターンを登録する。\n\n\nconst futurePatternUpdate = (state, updatePatternId) => {\n  console.log(\"====futurePatternUpdateここから====\");\n  console.log(Object.keys(state.userTaskInfo.calendar));\n  const today = new Date();\n  const nowYear = today.getFullYear();\n  const nowMonth = today.getMonth() + 1;\n  const nowDate = today.getDate();\n  const choicePatternTasks = state.userTaskInfo.tasks.filter(function (task) {\n    return task.patternInfo.some(task => task.patternID == updatePatternId);\n  }); // パターンIDに紐付くタスク一覧からカレンダーへの登録情報を抽出する。\n\n  const updateTasks = choicePatternTasks.map(task => {\n    // パターンが複数登録されているタスクへの対応として、選択されているパターンIDに該当する要素だけを抽出する。\n    const taskPattern = task.patternInfo.filter(function (patternInfo) {\n      return patternInfo.patternID == updatePatternId;\n    }); // 配列のタスクと抽出したパターン情報を整形して返す。\n\n    return {\n      order: taskPattern[0].order,\n      detail: task.detail,\n      // detail2: task.detail2,\n      flug: false\n    };\n  });\n\n  const keyMonthList = keyYear => {\n    return Object.keys(state.userTaskInfo.calendar[parseInt(keyYear)]);\n  };\n\n  const keyDateList = (keyYear, keyMonth) => {\n    return Object.keys(state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)]);\n  };\n\n  const dateTaskUpdate = (keyYear, keyMonth, keyDate) => {\n    if (state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].PatternId == updatePatternId) {\n      state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks = updateTasks;\n    }\n  }; // 登録されている年の連想配列のキーを全て取得\n\n\n  const keyYears = Object.keys(state.userTaskInfo.calendar);\n  keyYears.map(keyYear => {\n    if (parseInt(keyYear) == nowYear) {\n      // もし今年だったら、の処理\n      // 登録されている月の連想配列のキーを全て取得\n      const keyMonths = keyMonthList(keyYear);\n      keyMonths.map(keyMonth => {\n        if (parseInt(keyMonth) == nowMonth) {\n          // もし今月だったら\n          // 登録されている日の連想配列のキーを全て取得\n          const keyDates = keyDateList(keyYear, keyMonth);\n          keyDates.map(keyDate => {\n            if (parseInt(keyDate) > nowDate) {\n              // もし明日以降だったら登録内容を更新する\n              dateTaskUpdate(keyYear, keyMonth, keyDate);\n            } else if (parseInt(keyDate) == nowDate) {\n              // もし今日だったら、変更分だけ反映する。\n              // 処理未作成\n              const result = diff(state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks, updateTasks);\n              const updateArray = state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks.filter(function (task) {\n                return result.subs.some(sub => sub != task);\n              });\n              result.adds.map(add => {\n                // let Max: number = 0;\n                // const choicePatternTasks = state.userTaskInfo.tasks.filter(\n                //     function (task) {\n                //         return task.patternInfo.some(\n                //             (task) => task.patternID == add\n                //         );\n                //     }\n                // );\n                // choicePatternTasks.map((task) => {\n                //     let content = task.patternInfo.find(\n                //         (info) => (info.patternID = add)\n                //     );\n                //     Max < content.patternID ? (Max = content.patternID) : \"\";\n                // });\n                // const pushContent = { patternID: add, order: Max };\n                updateArray.push(add);\n              });\n              state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks = updateArray;\n            }\n          });\n        } else if (parseInt(keyMonth) > nowMonth) {\n          // もし来月以降だったら、すべて更新する。\n          const keyDates = keyDateList(keyYear, keyMonth);\n          keyDates.map(keyDate => {\n            dateTaskUpdate(keyYear, keyMonth, keyDate);\n          });\n        }\n      });\n    } else if (parseInt(keyYear) > nowYear) {\n      // もし来年以降だったら、の処理。全て更新する。\n      const keyMonths = keyMonthList(keyYear);\n      keyMonths.map(keyMonth => {\n        const keyDates = keyDateList(keyYear, keyMonth);\n        keyDates.map(keyDate => {\n          dateTaskUpdate(keyYear, keyMonth, keyDate);\n        });\n      });\n    }\n  });\n  console.log(\"====futurePatternUpdateここまで====\");\n};\n\nconst tasksModule = createSlice({\n  name: \"tasks\",\n  initialState,\n  reducers: {\n    init(state, action) {\n      const data = action.payload;\n      console.log(\"init data\");\n      console.log(data); // state = {...data};\n      // console.log(\"init state.userTaskInfo 前\");\n      // console.log(state.userTaskInfo);\n\n      state.userTaskInfo = data; // console.log(\"init state.userTaskInfo 後\");\n      // console.log(state.userTaskInfo);\n    },\n\n    Register(state, action) {\n      const data = action.payload;\n      state = _objectSpread(_objectSpread({}, state), data); // console.log('state');\n      // console.log(state);\n    },\n\n    allDelete(state) {\n      state = initialState;\n      console.log(\"check allDelete\");\n    },\n\n    // DayPlanにてタスクをクリックした際に完了フラグをtrueに変更する処理。引数にて年、月、日、タスクのインデックス番号を受け取っている。\n    taskCheckComplete(state, action) {\n      const index = state.userTaskInfo.calendar[action.payload[0]][action.payload[1]][action.payload[2]].tasks.findIndex(tasks => tasks.order == action.payload[3]);\n      console.log(index);\n      state.userTaskInfo.calendar[action.payload[0]][action.payload[1]][action.payload[2]].tasks[index].flug = !state.userTaskInfo.calendar[action.payload[0]][action.payload[1]][action.payload[2]].tasks[index].flug;\n    },\n\n    // 引数はstateと年、月、日、選択されているパターンIDの4つの数値が格納された配列\n    calendarPatternRegister(state, action) {\n      // stateから選択されているパターンIDが設定されているタスクを抽出する。\n      const choicePatternTasks = state.userTaskInfo.tasks.filter(function (task) {\n        return task.patternInfo.some(task => task.patternID == action.payload[3]);\n      }); // パターンIDに紐付くタスク一覧からカレンダーへの登録情報を抽出する。\n\n      const TodayTasks = choicePatternTasks.map(task => {\n        // パターンが複数登録されているタスクへの対応として、選択されているパターンIDに該当する要素だけを抽出する。\n        const taskPattern = task.patternInfo.filter(function (patternInfo) {\n          return patternInfo.patternID == action.payload[3];\n        }); // 配列のタスクと抽出したパターン情報を整形して返す。\n\n        return {\n          order: taskPattern[0].order,\n          detail: task.detail,\n          // detail2: task.detail2,\n          flug: false\n        };\n      }); // stateのMonthの連想配列に新しい日付の連想配列を追加する。\n      // 追加情報は引数の日とこれまでの処理で作成したカレンダー登録用情報\n\n      state.userTaskInfo.calendar[action.payload[0]][action.payload[1]] = _objectSpread(_objectSpread({}, state.userTaskInfo.calendar[action.payload[0]][action.payload[1]]), {}, {\n        [action.payload[2]]: {\n          PatternId: action.payload[3],\n          tasks: TodayTasks\n        }\n      }); // action.payload[3];\n\n      console.log(state.userTaskInfo.calendar[action.payload[0]][action.payload[1]][action.payload[2]]);\n    },\n\n    // タスクの詳細を設定する処理。引数のテキスト配列には[入力内容、連想配列のキー、タスクの配列を指定する数字]が格納されている。\n    taskDetailRegister(state, action) {\n      state.userTaskInfo.tasks[parseInt(action.payload[2])].detail = _objectSpread(_objectSpread({}, state.userTaskInfo.tasks[parseInt(action.payload[2])].detail), {}, {\n        [action.payload[1]]: action.payload[0]\n      });\n    },\n\n    // タスクを追加する処理。引数のテキスト配列には[入力内容、連想配列のキー、タスクの配列を指定する数字]が格納されている。\n    taskRegister(state, action) {\n      const registerTask = action.payload;\n      registerTask.patternInfo.map(content => {\n        const choicePatternTasks = state.userTaskInfo.tasks.filter(function (task) {\n          return task.patternInfo.some(task => task.patternID == content.patternID);\n        });\n        content.order = choicePatternTasks.length + 1;\n      });\n      console.log(registerTask);\n      state.userTaskInfo.tasks.push(registerTask);\n    },\n\n    // タスクのパターン登録状況を更新する。\n    taskPatternUpdate(state, action) {\n      // ここでやることは？\n      // まず引数にタスクの配列インデックス番号が必要\n      // パターンIDの配列を受け取る。\n      // 配列とstateを比較して、なければ登録。Orderは最大値+1。逆に削除されているものは除外。\n      const statePatternIdList = state.userTaskInfo.tasks[action.payload.index].patternInfo.map(content => {\n        return content.patternID;\n      });\n      const result = diff(statePatternIdList, action.payload.newChecked);\n      let updateArray;\n      console.log(result);\n      updateArray = state.userTaskInfo.tasks[action.payload.index].patternInfo.filter(function (content) {\n        // futurePatternUpdate(state,);\n        return result.subs.some(sub => sub != content.patternID);\n      });\n      result.adds.map(add => {\n        let Max = 0;\n        const choicePatternTasks = state.userTaskInfo.tasks.filter(function (task) {\n          return task.patternInfo.some(task => task.patternID == add);\n        });\n        choicePatternTasks.map(task => {\n          let content = task.patternInfo.find(info => info.patternID = add);\n          Max < content.patternID ? Max = content.patternID : \"\";\n        });\n        const pushContent = {\n          patternID: add,\n          order: Max\n        };\n        updateArray.push(pushContent); // futurePatternUpdate(state);\n      });\n      state.userTaskInfo.tasks[action.payload.index].patternInfo = updateArray;\n    },\n\n    // タスクを追加する処理。引数のテキスト配列には[入力内容、連想配列のキー、タスクの配列を指定する数字]が格納されている。\n    taskDelete(state, action) {\n      const deleteTask = state.userTaskInfo.tasks.splice(action.payload, 1);\n      console.log(deleteTask);\n    },\n\n    // タスクを追加する処理。引数のテキスト配列には[入力内容、連想配列のキー、タスクの配列を指定する数字]が格納されている。\n    taskRemovePattern(state, action) {\n      const index = state.userTaskInfo.tasks.findIndex(content => {\n        return content.detail[\"title\"] == action.payload.detailTitle;\n      });\n      const deletedTask = state.userTaskInfo.tasks[index].patternInfo.filter(function (content) {\n        return content.patternID != action.payload.patternId;\n      });\n      state.userTaskInfo.tasks[index].patternInfo = deletedTask;\n      console.log(deletedTask); // futurePatternUpdate(state);\n    }\n\n  }\n});\nexport const {\n  init,\n  Register,\n  allDelete,\n  taskCheckComplete,\n  calendarPatternRegister,\n  taskDetailRegister,\n  taskRegister,\n  taskPatternUpdate,\n  taskDelete,\n  taskRemovePattern\n} = tasksModule.actions;\nexport default tasksModule;","map":{"version":3,"sources":["C:/Users/blelm/Desktop/AppCreate/habitPlan/src/modules/tasksModule.tsx"],"names":["createSlice","initialState","userTaskInfo","calendar","Date","getFullYear","getMonth","getDate","PatternId","tasks","order","detail","flug","pattern","patternId","patternName","patternInfo","patternID","diff","olds","nexts","adds","filter","e","includes","subs","futurePatternUpdate","state","updatePatternId","console","log","Object","keys","today","nowYear","nowMonth","nowDate","choicePatternTasks","task","some","updateTasks","map","taskPattern","keyMonthList","keyYear","parseInt","keyDateList","keyMonth","dateTaskUpdate","keyDate","keyYears","keyMonths","keyDates","result","updateArray","sub","add","push","tasksModule","name","reducers","init","action","data","payload","Register","allDelete","taskCheckComplete","index","findIndex","calendarPatternRegister","TodayTasks","taskDetailRegister","taskRegister","registerTask","content","length","taskPatternUpdate","statePatternIdList","newChecked","Max","find","info","pushContent","taskDelete","deleteTask","splice","taskRemovePattern","detailTitle","deletedTask","actions"],"mappings":"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","sourcesContent":["import { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\r\nimport {\r\n    calendar,\r\n    pattern,\r\n    tasks,\r\n    userTask,\r\n    userTaskInfo,\r\n} from \"./userTasksType\";\r\n\r\ntype State = {\r\n    [key: string]: string;\r\n};\r\n\r\nconst initialState: userTask = {\r\n    userTaskInfo: {\r\n        calendar: {\r\n            [new Date(\"Thu, 22 Oct 2020 02:00:00\").getFullYear()]: {\r\n                [new Date(\"Thu, 22 Oct 2020 02:00:00\").getMonth() + 1]: {\r\n                    [new Date(\"Thu, 22 Oct 2020 02:00:00\").getDate()]: {\r\n                        PatternId: 1,\r\n                        tasks: [\r\n                            {\r\n                                order: 1,\r\n                                detail: {\r\n                                    [\"title\"]: \"title 22 1\",\r\n                                    [\"testDetail1\"]: \"testDetail1 22 1\",\r\n                                    [\"testDetail2\"]: \"testDetail1 22 1\",\r\n                                },\r\n                                flug: false,\r\n                            },\r\n                            {\r\n                                order: 2,\r\n                                detail: {\r\n                                    [\"title\"]: \"title 22 2\",\r\n                                    [\"testDetail1\"]: \"testDetail1 22 2\",\r\n                                    [\"testDetail2\"]: \"testDetail1 22 2\",\r\n                                },\r\n                                flug: false,\r\n                            },\r\n                        ],\r\n                    },\r\n                    [new Date(\"Thu, 23 Oct 2020 02:00:00\").getDate()]: {\r\n                        PatternId: 1,\r\n                        tasks: [\r\n                            {\r\n                                order: 1,\r\n                                detail: {\r\n                                    [\"title\"]: \"title 23 1\",\r\n                                    [\"testDetail1\"]: \"testDetail1 23 1\",\r\n                                    [\"testDetail2\"]: \"testDetail1 23 1\",\r\n                                },\r\n                                flug: false,\r\n                            },\r\n                            {\r\n                                order: 2,\r\n                                detail: {\r\n                                    [\"title\"]: \"title 23 2\",\r\n                                    [\"testDetail1\"]: \"testDetail1 23 2\",\r\n                                    [\"testDetail2\"]: \"testDetail1 23 2\",\r\n                                },\r\n                                flug: false,\r\n                            },\r\n                        ],\r\n                    },\r\n                },\r\n            },\r\n        },\r\n\r\n        pattern: [\r\n            {\r\n                patternId: 1,\r\n                patternName: \"testPattern1\",\r\n            },\r\n            {\r\n                patternId: 2,\r\n                patternName: \"testPattern2\",\r\n            },\r\n        ],\r\n        tasks: [\r\n            {\r\n                detail: {\r\n                    [\"title\"]: \"title 22 1\",\r\n                    [\"defalut\"]: \"defalut\",\r\n                    [\"testDetail1\"]: \"testDetail1 22 1\",\r\n                    [\"testDetail2\"]: \"testDetail1 22 1\",\r\n                },\r\n                patternInfo: [\r\n                    {\r\n                        patternID: 1,\r\n                        order: 1,\r\n                    },\r\n                ],\r\n            },\r\n            {\r\n                detail: {\r\n                    [\"title\"]: \"title 22 2\",\r\n                    [\"defalut\"]: \"defalut\",\r\n                    [\"testDetail1\"]: \"testDetail1 22 2\",\r\n                    [\"testDetail2\"]: \"testDetail1 22 2\",\r\n                },\r\n                patternInfo: [\r\n                    {\r\n                        patternID: 1,\r\n                        order: 2,\r\n                    },\r\n                ],\r\n            },\r\n            {\r\n                detail: {\r\n                    [\"title\"]: \"title 23 1\",\r\n                    [\"defalut\"]: \"defalut\",\r\n                    [\"testDetail1\"]: \"testDetail1 23 1\",\r\n                    [\"testDetail2\"]: \"testDetail1 23 1\",\r\n                },\r\n                patternInfo: [\r\n                    {\r\n                        patternID: 2,\r\n                        order: 1,\r\n                    },\r\n                    {\r\n                        patternID: 1,\r\n                        order: 3,\r\n                    },\r\n                ],\r\n            },\r\n            {\r\n                detail: {\r\n                    [\"title\"]: \"title 23 2\",\r\n                    [\"defalut\"]: \"defalut\",\r\n                    [\"testDetail2\"]: \"testDetail1 23 2\",\r\n                    [\"testDetail1\"]: \"testDetail1 23 2\",\r\n                },\r\n                patternInfo: [\r\n                    {\r\n                        patternID: 2,\r\n                        order: 2,\r\n                    },\r\n                ],\r\n            },\r\n        ],\r\n    },\r\n};\r\n\r\nconst diff = (olds: any[], nexts: any[]) => ({\r\n    adds: nexts.filter((e) => !olds.includes(e)),\r\n    subs: olds.filter((e) => !nexts.includes(e)),\r\n});\r\n\r\n// パターン更新時に未来に設定されているパターンの内容を更新する。\r\n// 更新対象はstate.calendar.tasks\r\n// 年月日が未来であり、かつ、パターンIDが同じものを対象に新しいパターンを登録する。\r\nconst futurePatternUpdate = (state: userTask, updatePatternId: number) => {\r\n    console.log(\"====futurePatternUpdateここから====\");\r\n\r\n    console.log(Object.keys(state.userTaskInfo.calendar));\r\n    const today = new Date();\r\n    const nowYear = today.getFullYear();\r\n    const nowMonth = today.getMonth() + 1;\r\n    const nowDate = today.getDate();\r\n\r\n    const choicePatternTasks = state.userTaskInfo.tasks.filter(function (task) {\r\n        return task.patternInfo.some(\r\n            (task) => task.patternID == updatePatternId\r\n        );\r\n    });\r\n\r\n    // パターンIDに紐付くタスク一覧からカレンダーへの登録情報を抽出する。\r\n    const updateTasks = choicePatternTasks.map((task) => {\r\n        // パターンが複数登録されているタスクへの対応として、選択されているパターンIDに該当する要素だけを抽出する。\r\n        const taskPattern = task.patternInfo.filter(function (patternInfo) {\r\n            return patternInfo.patternID == updatePatternId;\r\n        });\r\n\r\n        // 配列のタスクと抽出したパターン情報を整形して返す。\r\n        return {\r\n            order: taskPattern[0].order,\r\n            detail: task.detail,\r\n            // detail2: task.detail2,\r\n            flug: false,\r\n        };\r\n    });\r\n\r\n    const keyMonthList = (keyYear: string) => {\r\n        return Object.keys(state.userTaskInfo.calendar[parseInt(keyYear)]);\r\n    };\r\n    const keyDateList = (keyYear: string, keyMonth: string) => {\r\n        return Object.keys(\r\n            state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)]\r\n        );\r\n    };\r\n\r\n    const dateTaskUpdate = (\r\n        keyYear: string,\r\n        keyMonth: string,\r\n        keyDate: string\r\n    ) => {\r\n        if (\r\n            state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][\r\n                parseInt(keyDate)\r\n            ].PatternId == updatePatternId\r\n        ) {\r\n            state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][\r\n                parseInt(keyDate)\r\n            ].tasks = updateTasks;\r\n        }\r\n    };\r\n\r\n\r\n    // 登録されている年の連想配列のキーを全て取得\r\n    const keyYears = Object.keys(state.userTaskInfo.calendar);\r\n    keyYears.map((keyYear) => {\r\n        if (parseInt(keyYear) == nowYear) {\r\n            // もし今年だったら、の処理\r\n            // 登録されている月の連想配列のキーを全て取得\r\n            const keyMonths = keyMonthList(keyYear);\r\n\r\n            keyMonths.map((keyMonth) => {\r\n                if (parseInt(keyMonth) == nowMonth) {\r\n                    // もし今月だったら\r\n                    // 登録されている日の連想配列のキーを全て取得\r\n                    const keyDates = keyDateList(keyYear, keyMonth);\r\n                    keyDates.map((keyDate) => {\r\n                        if (parseInt(keyDate) > nowDate) {\r\n                            // もし明日以降だったら登録内容を更新する\r\n                            dateTaskUpdate(keyYear, keyMonth, keyDate);\r\n                        } else if (parseInt(keyDate) == nowDate) {\r\n                            // もし今日だったら、変更分だけ反映する。\r\n                            // 処理未作成\r\n                            const result = diff(state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks,updateTasks);\r\n                            const updateArray = state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks.filter(function (task) {\r\n                                return result.subs.some((sub) => sub != task);\r\n                            });\r\n\r\n                            result.adds.map((add) => {\r\n                                // let Max: number = 0;\r\n                                // const choicePatternTasks = state.userTaskInfo.tasks.filter(\r\n                                //     function (task) {\r\n                                //         return task.patternInfo.some(\r\n                                //             (task) => task.patternID == add\r\n                                //         );\r\n                                //     }\r\n                                // );\r\n                                // choicePatternTasks.map((task) => {\r\n                                //     let content = task.patternInfo.find(\r\n                                //         (info) => (info.patternID = add)\r\n                                //     );\r\n                                //     Max < content.patternID ? (Max = content.patternID) : \"\";\r\n                                // });\r\n                \r\n                                // const pushContent = { patternID: add, order: Max };\r\n                                updateArray.push(add);\r\n                            });\r\n                            state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks = updateArray;\r\n\r\n                        }\r\n                    });\r\n                } else if (parseInt(keyMonth) > nowMonth) {\r\n                    // もし来月以降だったら、すべて更新する。\r\n                    const keyDates = keyDateList(keyYear, keyMonth);\r\n                    keyDates.map((keyDate) => {\r\n                        dateTaskUpdate(keyYear, keyMonth, keyDate);\r\n                    });\r\n                }\r\n            });\r\n        } else if (parseInt(keyYear) > nowYear) {\r\n            // もし来年以降だったら、の処理。全て更新する。\r\n            const keyMonths = keyMonthList(keyYear);\r\n            keyMonths.map((keyMonth) => {\r\n                const keyDates = keyDateList(keyYear, keyMonth);\r\n                keyDates.map((keyDate) => {\r\n                    dateTaskUpdate(keyYear, keyMonth, keyDate);\r\n                });\r\n            });\r\n        }\r\n    });\r\n\r\n    console.log(\"====futurePatternUpdateここまで====\");\r\n};\r\n\r\nconst tasksModule = createSlice({\r\n    name: \"tasks\",\r\n    initialState,\r\n    reducers: {\r\n        init(state: userTask, action: PayloadAction<userTaskInfo>) {\r\n            const data = action.payload;\r\n            console.log(\"init data\");\r\n            console.log(data);\r\n            // state = {...data};\r\n            // console.log(\"init state.userTaskInfo 前\");\r\n            // console.log(state.userTaskInfo);\r\n            state.userTaskInfo = data;\r\n            // console.log(\"init state.userTaskInfo 後\");\r\n            // console.log(state.userTaskInfo);\r\n        },\r\n        Register(state: userTask, action: PayloadAction<userTask>) {\r\n            const data = action.payload;\r\n\r\n            state = { ...state, ...data };\r\n            // console.log('state');\r\n            // console.log(state);\r\n        },\r\n        allDelete(state: userTask) {\r\n            state = initialState;\r\n            console.log(\"check allDelete\");\r\n        },\r\n        // DayPlanにてタスクをクリックした際に完了フラグをtrueに変更する処理。引数にて年、月、日、タスクのインデックス番号を受け取っている。\r\n        taskCheckComplete(state: userTask, action: PayloadAction<number[]>) {\r\n            const index = state.userTaskInfo.calendar[action.payload[0]][\r\n                action.payload[1]\r\n            ][action.payload[2]].tasks.findIndex(\r\n                (tasks) => tasks.order == action.payload[3]\r\n            );\r\n            console.log(index);\r\n            state.userTaskInfo.calendar[action.payload[0]][action.payload[1]][\r\n                action.payload[2]\r\n            ].tasks[index].flug = !state.userTaskInfo.calendar[\r\n                action.payload[0]\r\n            ][action.payload[1]][action.payload[2]].tasks[index].flug;\r\n        },\r\n        // 引数はstateと年、月、日、選択されているパターンIDの4つの数値が格納された配列\r\n        calendarPatternRegister(\r\n            state: userTask,\r\n            action: PayloadAction<number[]>\r\n        ) {\r\n            // stateから選択されているパターンIDが設定されているタスクを抽出する。\r\n            const choicePatternTasks = state.userTaskInfo.tasks.filter(\r\n                function (task) {\r\n                    return task.patternInfo.some(\r\n                        (task) => task.patternID == action.payload[3]\r\n                    );\r\n                }\r\n            );\r\n\r\n            // パターンIDに紐付くタスク一覧からカレンダーへの登録情報を抽出する。\r\n            const TodayTasks = choicePatternTasks.map((task) => {\r\n                // パターンが複数登録されているタスクへの対応として、選択されているパターンIDに該当する要素だけを抽出する。\r\n                const taskPattern = task.patternInfo.filter(function (\r\n                    patternInfo\r\n                ) {\r\n                    return patternInfo.patternID == action.payload[3];\r\n                });\r\n\r\n                // 配列のタスクと抽出したパターン情報を整形して返す。\r\n                return {\r\n                    order: taskPattern[0].order,\r\n                    detail: task.detail,\r\n                    // detail2: task.detail2,\r\n                    flug: false,\r\n                };\r\n            });\r\n\r\n            // stateのMonthの連想配列に新しい日付の連想配列を追加する。\r\n            // 追加情報は引数の日とこれまでの処理で作成したカレンダー登録用情報\r\n            state.userTaskInfo.calendar[action.payload[0]][\r\n                action.payload[1]\r\n            ] = {\r\n                ...state.userTaskInfo.calendar[action.payload[0]][\r\n                    action.payload[1]\r\n                ],\r\n                [action.payload[2]]: {\r\n                    PatternId: action.payload[3],\r\n                    tasks: TodayTasks,\r\n                },\r\n            };\r\n\r\n            // action.payload[3];\r\n            console.log(\r\n                state.userTaskInfo.calendar[action.payload[0]][\r\n                    action.payload[1]\r\n                ][action.payload[2]]\r\n            );\r\n        },\r\n        // タスクの詳細を設定する処理。引数のテキスト配列には[入力内容、連想配列のキー、タスクの配列を指定する数字]が格納されている。\r\n        taskDetailRegister(state: userTask, action: PayloadAction<string[]>) {\r\n            state.userTaskInfo.tasks[parseInt(action.payload[2])].detail = {\r\n                ...state.userTaskInfo.tasks[parseInt(action.payload[2])].detail,\r\n                [action.payload[1]]: action.payload[0],\r\n            };\r\n        },\r\n        // タスクを追加する処理。引数のテキスト配列には[入力内容、連想配列のキー、タスクの配列を指定する数字]が格納されている。\r\n        taskRegister(state: userTask, action: PayloadAction<tasks>) {\r\n            const registerTask = action.payload;\r\n            registerTask.patternInfo.map((content) => {\r\n                const choicePatternTasks = state.userTaskInfo.tasks.filter(\r\n                    function (task) {\r\n                        return task.patternInfo.some(\r\n                            (task) => task.patternID == content.patternID\r\n                        );\r\n                    }\r\n                );\r\n                content.order = choicePatternTasks.length + 1;\r\n            });\r\n            console.log(registerTask);\r\n            state.userTaskInfo.tasks.push(registerTask);\r\n        },\r\n        // タスクのパターン登録状況を更新する。\r\n        taskPatternUpdate(\r\n            state: userTask,\r\n            action: PayloadAction<{\r\n                newChecked: number[];\r\n                index: number;\r\n            }>\r\n        ) {\r\n            // ここでやることは？\r\n            // まず引数にタスクの配列インデックス番号が必要\r\n            // パターンIDの配列を受け取る。\r\n            // 配列とstateを比較して、なければ登録。Orderは最大値+1。逆に削除されているものは除外。\r\n\r\n            const statePatternIdList = state.userTaskInfo.tasks[\r\n                action.payload.index\r\n            ].patternInfo.map((content) => {\r\n                return content.patternID;\r\n            });\r\n            const result = diff(statePatternIdList, action.payload.newChecked);\r\n            let updateArray: {\r\n                patternID: number;\r\n                order: number;\r\n            }[];\r\n            console.log(result);\r\n\r\n            updateArray = state.userTaskInfo.tasks[\r\n                action.payload.index\r\n            ].patternInfo.filter(function (content) {\r\n                // futurePatternUpdate(state,);\r\n                return result.subs.some((sub) => sub != content.patternID);\r\n            });\r\n            \r\n            result.adds.map((add) => {\r\n                let Max: number = 0;\r\n                const choicePatternTasks = state.userTaskInfo.tasks.filter(\r\n                    function (task) {\r\n                        return task.patternInfo.some(\r\n                            (task) => task.patternID == add\r\n                            );\r\n                        }\r\n                        );\r\n                        choicePatternTasks.map((task) => {\r\n                            let content = task.patternInfo.find(\r\n                                (info) => (info.patternID = add)\r\n                                );\r\n                                Max < content.patternID ? (Max = content.patternID) : \"\";\r\n                            });\r\n                            \r\n                            const pushContent = { patternID: add, order: Max };\r\n                            updateArray.push(pushContent);\r\n                            // futurePatternUpdate(state);\r\n            });\r\n\r\n            state.userTaskInfo.tasks[\r\n                action.payload.index\r\n            ].patternInfo = updateArray;\r\n        },\r\n        // タスクを追加する処理。引数のテキスト配列には[入力内容、連想配列のキー、タスクの配列を指定する数字]が格納されている。\r\n        taskDelete(state: userTask, action: PayloadAction<number>) {\r\n            const deleteTask = state.userTaskInfo.tasks.splice(\r\n                action.payload,\r\n                1\r\n            );\r\n            console.log(deleteTask);\r\n        },\r\n        // タスクを追加する処理。引数のテキスト配列には[入力内容、連想配列のキー、タスクの配列を指定する数字]が格納されている。\r\n        taskRemovePattern(\r\n            state: userTask,\r\n            action: PayloadAction<{ patternId: number; detailTitle: string }>\r\n        ) {\r\n            const index = state.userTaskInfo.tasks.findIndex((content) => {\r\n                return content.detail[\"title\"] == action.payload.detailTitle;\r\n            });\r\n            const deletedTask = state.userTaskInfo.tasks[\r\n                index\r\n            ].patternInfo.filter(function (content) {\r\n                return content.patternID != action.payload.patternId;\r\n            });\r\n            state.userTaskInfo.tasks[index].patternInfo = deletedTask;\r\n            console.log(deletedTask);\r\n            // futurePatternUpdate(state);\r\n        },\r\n    },\r\n});\r\n\r\nexport const {\r\n    init,\r\n    Register,\r\n    allDelete,\r\n    taskCheckComplete,\r\n    calendarPatternRegister,\r\n    taskDetailRegister,\r\n    taskRegister,\r\n    taskPatternUpdate,\r\n    taskDelete,\r\n    taskRemovePattern,\r\n} = tasksModule.actions;\r\n\r\nexport default tasksModule;\r\n"]},"metadata":{},"sourceType":"module"}