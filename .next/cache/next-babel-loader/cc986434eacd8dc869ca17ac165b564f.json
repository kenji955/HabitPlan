{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { createSlice } from \"@reduxjs/toolkit\"; // import { Task } from '../Types'\n\nimport { firebase } from \"../components/test/firebaseTest/firebaseTest\";\nimport { useRegisterData } from \"../components/test/firebaseTest/DBFetch\";\nconst initialState = {\n  [\"test\"]: \"test\"\n};\n\nconst useDatabase = () => {\n  // 同じパスでは毎回同じ結果が得られるのでmemo化しておく\n  return useMemo(() => firebase.database().ref(\"/sample\"), []);\n};\n\nconst useSetDocument = ref => {\n  const updateDocument = useCallback(document => {\n    // refについては前回の記事参照\n    // setに登録したいデータを渡してあげれば登録できる\n    ref.set(document);\n  }, [ref]);\n  return updateDocument;\n};\n\nconst useFetchData = ref => {\n  const {\n    0: data,\n    1: setData\n  } = useState();\n  useEffect(() => {\n    // イベントリスナーを追加するにはonを使う\n    ref.on(\"value\", snapshot => {\n      // パスに対する全データを含むsnapshotが渡される\n      // ない場合はnullが変えるので存在をチェックしておく\n      if (snapshot === null || snapshot === void 0 ? void 0 : snapshot.val()) {\n        setData(snapshot.val());\n      }\n    });\n    return () => {\n      ref.off();\n    }; // refの変更に応じて再取得する\n    //   指定したパスのデータに対する更新をすべて検知するにはvalueを指定すれば良い。\n  }, [ref]); // データを返却する\n\n  return {\n    data\n  };\n}; // 実際に呼び出す際はこちらを使う\n\n\nexport const useFetchAllData = () => {\n  // refを取得して\n  const ref = useDatabase(); // ref渡してデータを取得する\n\n  return useFetchData(ref);\n};\nconst tasksModule = createSlice({\n  name: \"tasks\",\n  initialState,\n  reducers: {\n    RegisterData(state, action) {\n      // // 前回作ったuseDatabase()を使いref取得\n      // const ref = useDatabase();\n      // const setDocument = useSetDocument(ref);\n      // // 登録済みのデータを全部取得する\n      // const { data: registeredData } = useFetchAllData();\n      // // データを登録する関数を返却する\n      // const registerData = useCallback(\n      //     (registerData: State) => {\n      //         // 既存のデータと登録するkey-valueを合わせて登録関数に渡す\n      //         setDocument({ ...registeredData, ...registerData });\n      //         state = { ...registeredData, ...registerData };\n      //     },\n      //     [setDocument, registeredData]\n      // );\n      const registerData = useRegisterData();\n      const data = action.payload;\n      state = _objectSpread(_objectSpread({}, state), data);\n      registerData(action.payload); // 返した関数を利用することで、登録済みデータ全て+登録したいデータをDBに保管できる\n      //   return registerData;\n    } // addTask(state: State, action: PayloadAction<string>) {\n    //     state.count++;\n    //     const newTask: Task = {\n    //         id: state.count,\n    //         title: action.payload,\n    //         done: false,\n    //     };\n    //     state.tasks = [newTask, ...state.tasks];\n    // },\n    // doneTask(state: State, action: PayloadAction<Task>) {\n    //     const task = state.tasks.find((t) => t.id === action.payload.id);\n    //     if (task) {\n    //         task.done = !task.done;\n    //     }\n    // },\n    // deleteTask(state: State, action: PayloadAction<Task>) {\n    //     state.tasks = state.tasks.filter((t) => t.id !== action.payload.id);\n    // },\n\n\n  }\n}); // export const { addTask, doneTask, deleteTask } = tasksModule.actions;\n\nexport const {\n  RegisterData\n} = tasksModule.actions;\nexport default tasksModule;","map":{"version":3,"sources":["C:/Users/blelm/Desktop/AppCreate/habitPlan/src/modules/tasksModule.tsx"],"names":["useCallback","useEffect","useMemo","useState","createSlice","firebase","useRegisterData","initialState","useDatabase","database","ref","useSetDocument","updateDocument","document","set","useFetchData","data","setData","on","snapshot","val","off","useFetchAllData","tasksModule","name","reducers","RegisterData","state","action","registerData","payload","actions"],"mappings":";;;;;;AAAA,SAASA,WAAT,EAAsBC,SAAtB,EAAiCC,OAAjC,EAA0CC,QAA1C,QAA0D,OAA1D;AACA,SAASC,WAAT,QAA2C,kBAA3C,C,CACA;;AAEA,SAASC,QAAT,QAAyB,8CAAzB;AACA,SAASC,eAAT,QAA6D,yCAA7D;AAMA,MAAMC,YAAmB,GAAG;AACxB,GAAC,MAAD,GAAU;AADc,CAA5B;;AAIA,MAAMC,WAAW,GAAG,MAAM;AACtB;AACA,SAAON,OAAO,CAAC,MAAMG,QAAQ,CAACI,QAAT,GAAoBC,GAApB,CAAwB,SAAxB,CAAP,EAA2C,EAA3C,CAAd;AACH,CAHD;;AAKA,MAAMC,cAAc,GAAID,GAAD,IAAsC;AACzD,QAAME,cAAc,GAAGZ,WAAW,CAC7Ba,QAAD,IAAuB;AACnB;AACA;AACAH,IAAAA,GAAG,CAACI,GAAJ,CAAQD,QAAR;AACH,GAL6B,EAM9B,CAACH,GAAD,CAN8B,CAAlC;AAQA,SAAOE,cAAP;AACH,CAVD;;AAYA,MAAMG,YAAY,GAAIL,GAAD,IAAsC;AACvD,QAAM;AAAA,OAACM,IAAD;AAAA,OAAOC;AAAP,MAAkBd,QAAQ,EAAhC;AACAF,EAAAA,SAAS,CAAC,MAAM;AACZ;AACAS,IAAAA,GAAG,CAACQ,EAAJ,CAAO,OAAP,EAAiBC,QAAD,IAAmB;AAC/B;AACA;AACA,UAAIA,QAAJ,aAAIA,QAAJ,uBAAIA,QAAQ,CAAEC,GAAV,EAAJ,EAAqB;AACjBH,QAAAA,OAAO,CAACE,QAAQ,CAACC,GAAT,EAAD,CAAP;AACH;AACJ,KAND;AAOA,WAAO,MAAM;AACTV,MAAAA,GAAG,CAACW,GAAJ;AACH,KAFD,CATY,CAYZ;AACA;AACH,GAdQ,EAcN,CAACX,GAAD,CAdM,CAAT,CAFuD,CAiBvD;;AACA,SAAO;AAAEM,IAAAA;AAAF,GAAP;AACH,CAnBD,C,CAqBA;;;AACA,OAAO,MAAMM,eAAe,GAAG,MAAM;AACjC;AACA,QAAMZ,GAAG,GAAGF,WAAW,EAAvB,CAFiC,CAGjC;;AACA,SAAOO,YAAY,CAACL,GAAD,CAAnB;AACH,CALM;AAOP,MAAMa,WAAW,GAAGnB,WAAW,CAAC;AAC5BoB,EAAAA,IAAI,EAAE,OADsB;AAE5BjB,EAAAA,YAF4B;AAG5BkB,EAAAA,QAAQ,EAAE;AACNC,IAAAA,YAAY,CAACC,KAAD,EAAeC,MAAf,EAA6C;AACrD;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,YAAMC,YAAY,GAAGvB,eAAe,EAApC;AACA,YAAMU,IAAI,GAAGY,MAAM,CAACE,OAApB;AAEAH,MAAAA,KAAK,mCAAOA,KAAP,GAAgBX,IAAhB,CAAL;AACAa,MAAAA,YAAY,CAACD,MAAM,CAACE,OAAR,CAAZ,CArBqD,CAuBrD;AACA;AACH,KA1BK,CA4BN;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA/CM;AAHkB,CAAD,CAA/B,C,CAsDA;;AACA,OAAO,MAAM;AAAEJ,EAAAA;AAAF,IAAmBH,WAAW,CAACQ,OAArC;AAEP,eAAeR,WAAf","sourcesContent":["import { useCallback, useEffect, useMemo, useState } from \"react\";\r\nimport { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\r\n// import { Task } from '../Types'\r\n\r\nimport { firebase } from \"../components/test/firebaseTest/firebaseTest\";\r\nimport { useRegisterData, useUpdateData, useDelteData } from \"../components/test/firebaseTest/DBFetch\";\r\n\r\ntype State = {\r\n    [key: string]: string;\r\n};\r\n\r\nconst initialState: State = {\r\n    [\"test\"]: \"test\",\r\n};\r\n\r\nconst useDatabase = () => {\r\n    // 同じパスでは毎回同じ結果が得られるのでmemo化しておく\r\n    return useMemo(() => firebase.database().ref(\"/sample\"), []);\r\n};\r\n\r\nconst useSetDocument = (ref: firebase.database.Reference) => {\r\n    const updateDocument = useCallback(\r\n        (document: unknown) => {\r\n            // refについては前回の記事参照\r\n            // setに登録したいデータを渡してあげれば登録できる\r\n            ref.set(document);\r\n        },\r\n        [ref]\r\n    );\r\n    return updateDocument;\r\n};\r\n\r\nconst useFetchData = (ref: firebase.database.Reference) => {\r\n    const [data, setData] = useState<{ [key: string]: string }>();\r\n    useEffect(() => {\r\n        // イベントリスナーを追加するにはonを使う\r\n        ref.on(\"value\", (snapshot: any) => {\r\n            // パスに対する全データを含むsnapshotが渡される\r\n            // ない場合はnullが変えるので存在をチェックしておく\r\n            if (snapshot?.val()) {\r\n                setData(snapshot.val());\r\n            }\r\n        });\r\n        return () => {\r\n            ref.off();\r\n        };\r\n        // refの変更に応じて再取得する\r\n        //   指定したパスのデータに対する更新をすべて検知するにはvalueを指定すれば良い。\r\n    }, [ref]);\r\n    // データを返却する\r\n    return { data };\r\n};\r\n\r\n// 実際に呼び出す際はこちらを使う\r\nexport const useFetchAllData = () => {\r\n    // refを取得して\r\n    const ref = useDatabase();\r\n    // ref渡してデータを取得する\r\n    return useFetchData(ref);\r\n};\r\n\r\nconst tasksModule = createSlice({\r\n    name: \"tasks\",\r\n    initialState,\r\n    reducers: {\r\n        RegisterData(state: State, action: PayloadAction<State>) {\r\n            // // 前回作ったuseDatabase()を使いref取得\r\n            // const ref = useDatabase();\r\n            // const setDocument = useSetDocument(ref);\r\n            // // 登録済みのデータを全部取得する\r\n            // const { data: registeredData } = useFetchAllData();\r\n\r\n            // // データを登録する関数を返却する\r\n            // const registerData = useCallback(\r\n            //     (registerData: State) => {\r\n            //         // 既存のデータと登録するkey-valueを合わせて登録関数に渡す\r\n            //         setDocument({ ...registeredData, ...registerData });\r\n            //         state = { ...registeredData, ...registerData };\r\n            //     },\r\n            //     [setDocument, registeredData]\r\n            // );\r\n\r\n            const registerData = useRegisterData();\r\n            const data = action.payload;\r\n\r\n            state = {...state,...data};\r\n            registerData(action.payload);\r\n\r\n            // 返した関数を利用することで、登録済みデータ全て+登録したいデータをDBに保管できる\r\n            //   return registerData;\r\n        },\r\n\r\n        // addTask(state: State, action: PayloadAction<string>) {\r\n        //     state.count++;\r\n\r\n        //     const newTask: Task = {\r\n        //         id: state.count,\r\n        //         title: action.payload,\r\n        //         done: false,\r\n        //     };\r\n\r\n        //     state.tasks = [newTask, ...state.tasks];\r\n        // },\r\n        // doneTask(state: State, action: PayloadAction<Task>) {\r\n        //     const task = state.tasks.find((t) => t.id === action.payload.id);\r\n        //     if (task) {\r\n        //         task.done = !task.done;\r\n        //     }\r\n        // },\r\n        // deleteTask(state: State, action: PayloadAction<Task>) {\r\n        //     state.tasks = state.tasks.filter((t) => t.id !== action.payload.id);\r\n        // },\r\n    },\r\n});\r\n\r\n// export const { addTask, doneTask, deleteTask } = tasksModule.actions;\r\nexport const { RegisterData } = tasksModule.actions;\r\n\r\nexport default tasksModule;\r\n"]},"metadata":{},"sourceType":"module"}