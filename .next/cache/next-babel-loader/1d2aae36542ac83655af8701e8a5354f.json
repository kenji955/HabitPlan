{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { createSlice } from \"@reduxjs/toolkit\";\nimport { useState } from \"react\";\nimport { useRegisterData } from \"../components/test/firebaseTest/DBFetch\";\nconst initialState = {\n  userTaskInfo: {\n    calendar: {\n      [new Date(\"Thu, 22 Oct 2020 02:00:00\").getFullYear()]: {\n        [new Date(\"Thu, 22 Oct 2020 02:00:00\").getMonth() + 1]: {\n          [new Date(\"Thu, 22 Oct 2020 02:00:00\").getDate()]: {\n            PatternId: 1,\n            tasks: [{\n              order: 1,\n              detail: {\n                [\"タスク名\"]: \"タスク名 22 1\",\n                [\"testDetail1\"]: \"testDetail1 22 1\",\n                [\"testDetail2\"]: \"testDetail1 22 1\"\n              },\n              flug: false\n            }, {\n              order: 2,\n              detail: {\n                [\"タスク名\"]: \"タスク名 22 2\",\n                [\"testDetail1\"]: \"testDetail1 22 2\",\n                [\"testDetail2\"]: \"testDetail1 22 2\"\n              },\n              flug: false\n            }]\n          },\n          [new Date(\"Thu, 23 Oct 2020 02:00:00\").getDate()]: {\n            PatternId: 1,\n            tasks: [{\n              order: 1,\n              detail: {\n                [\"タスク名\"]: \"タスク名 23 1\",\n                [\"testDetail1\"]: \"testDetail1 23 1\",\n                [\"testDetail2\"]: \"testDetail1 23 1\"\n              },\n              flug: false\n            }, {\n              order: 2,\n              detail: {\n                [\"タスク名\"]: \"タスク名 23 2\",\n                [\"testDetail1\"]: \"testDetail1 23 2\",\n                [\"testDetail2\"]: \"testDetail1 23 2\"\n              },\n              flug: false\n            }]\n          }\n        }\n      }\n    },\n    pattern: [{\n      patternId: 1,\n      patternName: \"testPattern1\"\n    }, {\n      patternId: 2,\n      patternName: \"testPattern2\"\n    }],\n    tasks: [{\n      detail: {\n        [\"タスク名\"]: \"タスク名 22 1\",\n        [\"defalut\"]: \"defalut\",\n        [\"testDetail1\"]: \"testDetail1 22 1\",\n        [\"testDetail2\"]: \"testDetail1 22 1\"\n      },\n      patternInfo: [{\n        patternID: 1,\n        order: 1\n      }]\n    }, {\n      detail: {\n        [\"タスク名\"]: \"タスク名 22 2\",\n        [\"defalut\"]: \"defalut\",\n        [\"testDetail1\"]: \"testDetail1 22 2\",\n        [\"testDetail2\"]: \"testDetail1 22 2\"\n      },\n      patternInfo: [{\n        patternID: 1,\n        order: 2\n      }]\n    }, {\n      detail: {\n        [\"タスク名\"]: \"タスク名 23 1\",\n        [\"defalut\"]: \"defalut\",\n        [\"testDetail1\"]: \"testDetail1 23 1\",\n        [\"testDetail2\"]: \"testDetail1 23 1\"\n      },\n      patternInfo: [{\n        patternID: 2,\n        order: 1\n      }, {\n        patternID: 1,\n        order: 3\n      }]\n    }, {\n      detail: {\n        [\"タスク名\"]: \"タスク名 23 2\",\n        [\"defalut\"]: \"defalut\",\n        [\"testDetail2\"]: \"testDetail1 23 2\",\n        [\"testDetail1\"]: \"testDetail1 23 2\"\n      },\n      patternInfo: [{\n        patternID: 2,\n        order: 2\n      }]\n    }]\n  }\n}; // const diff = (olds: any[], nexts: any[]) => ({\n//     adds: nexts.filter((e) => !olds.includes(e)),\n//     subs: olds.filter((e) => !nexts.includes(e)),\n// });\n// パターン更新時に未来に設定されているパターンの内容を更新する。\n// 更新対象はstate.calendar.tasks\n// 年月日が未来であり、かつ、パターンIDが同じものを対象に新しいパターンを登録する。\n\nconst futurePatternUpdate = (state, updatePatternId) => {\n  console.log(\"====futurePatternUpdateここから====\");\n  console.log(Object.keys(state.userTaskInfo.calendar));\n  const today = new Date();\n  const nowYear = today.getFullYear();\n  const nowMonth = today.getMonth() + 1;\n  const nowDate = today.getDate();\n  const choicePatternTasks = state.userTaskInfo.tasks.filter(function (task) {\n    return task.patternInfo.some(task => task.patternID == updatePatternId);\n  }); // パターンIDに紐付くタスク一覧からカレンダーへの登録情報を抽出する。\n\n  const updateTasks = choicePatternTasks.map(task => {\n    // パターンが複数登録されているタスクへの対応として、選択されているパターンIDに該当する要素だけを抽出する。\n    const taskPattern = task.patternInfo.filter(function (patternInfo) {\n      return patternInfo.patternID == updatePatternId;\n    }); // 配列のタスクと抽出したパターン情報を整形して返す。\n\n    return {\n      order: taskPattern[0].order,\n      detail: task.detail,\n      // detail2: task.detail2,\n      flug: false\n    };\n  });\n\n  const keyMonthList = keyYear => {\n    return Object.keys(state.userTaskInfo.calendar[parseInt(keyYear)]);\n  };\n\n  const keyDateList = (keyYear, keyMonth) => {\n    return Object.keys(state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)]);\n  };\n\n  const dateTaskUpdate = (keyYear, keyMonth, keyDate) => {\n    if (state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].PatternId == updatePatternId) {\n      state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks = updateTasks;\n      console.log(\"===dateTaskUpdate===\");\n      console.log(keyYear);\n      console.log(keyMonth);\n      console.log(keyDate);\n      console.log(updateTasks);\n    }\n  };\n\n  const diff = (olds, nexts) => ({\n    adds: nexts.filter(e => !olds.includes(e)),\n    subs: olds.filter(e => !nexts.includes(e))\n  }); // 登録されている年の連想配列のキーを全て取得\n\n\n  const keyYears = Object.keys(state.userTaskInfo.calendar);\n  keyYears.map(keyYear => {\n    if (parseInt(keyYear) == nowYear) {\n      // もし今年だったら、の処理\n      // 登録されている月の連想配列のキーを全て取得\n      const keyMonths = keyMonthList(keyYear);\n      keyMonths.map(keyMonth => {\n        if (parseInt(keyMonth) == nowMonth) {\n          // もし今月だったら\n          // 登録されている日の連想配列のキーを全て取得\n          const keyDates = keyDateList(keyYear, keyMonth);\n          keyDates.map(keyDate => {\n            if (parseInt(keyDate) > nowDate) {\n              // もし明日以降だったら登録内容を更新する\n              dateTaskUpdate(keyYear, keyMonth, keyDate);\n            } else if (parseInt(keyDate) == nowDate) {\n              // もし今日だったら、変更分だけ反映する。\n              // 処理未作成\n              if (state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].PatternId == updatePatternId) {\n                const result = diff(state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks, updateTasks);\n                const updateArray = state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks.filter(function (task) {\n                  return result.subs.some(sub => sub != task);\n                });\n                result.adds.map(add => {\n                  updateArray.push(add);\n                });\n                state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][parseInt(keyDate)].tasks = updateArray;\n              }\n            }\n          });\n        } else if (parseInt(keyMonth) > nowMonth) {\n          // もし来月以降だったら、すべて更新する。\n          const keyDates = keyDateList(keyYear, keyMonth);\n          keyDates.map(keyDate => {\n            dateTaskUpdate(keyYear, keyMonth, keyDate);\n          });\n        }\n      });\n    } else if (parseInt(keyYear) > nowYear) {\n      // もし来年以降だったら、の処理。全て更新する。\n      const keyMonths = keyMonthList(keyYear);\n      keyMonths.map(keyMonth => {\n        const keyDates = keyDateList(keyYear, keyMonth);\n        keyDates.map(keyDate => {\n          dateTaskUpdate(keyYear, keyMonth, keyDate);\n        });\n      });\n    }\n  });\n  console.log(\"====futurePatternUpdateここまで====\");\n};\n\nexport default function tasksModule() {\n  const {\n    0: key,\n    1: setKey\n  } = useState(true);\n  const registerData = useRegisterData(key);\n  registerData();\n  return createSlice({\n    name: \"tasks\",\n    initialState,\n    reducers: {\n      init(state, action) {\n        const data = action.payload;\n        console.log(\"init data\");\n        console.log(data); // state = {...data};\n        // console.log(\"init state.userTaskInfo 前\");\n        // console.log(state.userTaskInfo);\n\n        state.userTaskInfo = data; // console.log(\"init state.userTaskInfo 後\");\n        // console.log(state.userTaskInfo);\n      },\n\n      Register(state, action) {\n        const data = action.payload;\n        state = _objectSpread(_objectSpread({}, state), data); // console.log('state');\n        // console.log(state);\n      },\n\n      allDelete(state) {\n        state = initialState;\n        console.log(\"check allDelete\");\n      },\n\n      // DayPlanにてタスクをクリックした際に完了フラグをtrueに変更する処理。引数にて年、月、日、タスクのインデックス番号を受け取っている。\n      taskCheckComplete(state, action) {\n        const index = state.userTaskInfo.calendar[action.payload[0]][action.payload[1]][action.payload[2]].tasks.findIndex(tasks => tasks.order == action.payload[3]);\n        console.log(index);\n        state.userTaskInfo.calendar[action.payload[0]][action.payload[1]][action.payload[2]].tasks[index].flug = !state.userTaskInfo.calendar[action.payload[0]][action.payload[1]][action.payload[2]].tasks[index].flug;\n        setKey(!key);\n      },\n\n      // 引数はstateと年、月、日、選択されているパターンIDの4つの数値が格納された配列\n      calendarPatternRegister(state, action) {\n        // stateから選択されているパターンIDが設定されているタスクを抽出する。\n        const choicePatternTasks = state.userTaskInfo.tasks.filter(function (task) {\n          return task.patternInfo.some(task => task.patternID == action.payload[3]);\n        }); // パターンIDに紐付くタスク一覧からカレンダーへの登録情報を抽出する。\n\n        const TodayTasks = choicePatternTasks.map(task => {\n          // パターンが複数登録されているタスクへの対応として、選択されているパターンIDに該当する要素だけを抽出する。\n          const taskPattern = task.patternInfo.filter(function (patternInfo) {\n            return patternInfo.patternID == action.payload[3];\n          }); // 配列のタスクと抽出したパターン情報を整形して返す。\n\n          return {\n            order: taskPattern[0].order,\n            detail: task.detail,\n            // detail2: task.detail2,\n            flug: false\n          };\n        }); // ここに年がなかった時の処理を加える\n\n        if (action.payload[0] in state.userTaskInfo.calendar) {\n          // stateのMonthの連想配列に新しい日付の連想配列を追加する。\n          // 追加情報は引数の日とこれまでの処理で作成したカレンダー登録用情報\n          state.userTaskInfo.calendar[action.payload[0]][action.payload[1]] = _objectSpread(_objectSpread({}, state.userTaskInfo.calendar[action.payload[0]][action.payload[1]]), {}, {\n            [action.payload[2]]: {\n              PatternId: action.payload[3],\n              tasks: TodayTasks\n            }\n          });\n        } else {\n          // stateのMonthの連想配列に新しい日付の連想配列を追加する。\n          // 追加情報は引数の日とこれまでの処理で作成したカレンダー登録用情報\n          state.userTaskInfo.calendar[action.payload[0]] = _objectSpread(_objectSpread({}, state.userTaskInfo.calendar[action.payload[0]]), {}, {\n            [action.payload[1]]: {\n              [action.payload[2]]: {\n                PatternId: action.payload[3],\n                tasks: TodayTasks\n              }\n            }\n          });\n        } // action.payload[3];\n        // console.log(\n        //     state.userTaskInfo.calendar[action.payload[0]][\n        //         action.payload[1]\n        //     ][action.payload[2]]\n        // );\n\n\n        setKey(!key);\n      },\n\n      // タスクの詳細を設定する処理。引数のテキスト配列には[入力内容、連想配列のキー、タスクの配列を指定する数字]が格納されている。\n      taskDetailRegister(state, action) {\n        state.userTaskInfo.tasks[parseInt(action.payload[2])].detail = _objectSpread(_objectSpread({}, state.userTaskInfo.tasks[parseInt(action.payload[2])].detail), {}, {\n          [action.payload[1]]: action.payload[0]\n        });\n        setKey(!key);\n      },\n\n      // タスクを追加する処理。引数のテキスト配列には[入力内容、連想配列のキー、タスクの配列を指定する数字]が格納されている。\n      taskRegister(state, action) {\n        const registerTask = action.payload;\n        registerTask.patternInfo.map(content => {\n          const choicePatternTasks = state.userTaskInfo.tasks.filter(function (task) {\n            return task.patternInfo.some(task => task.patternID == content.patternID);\n          });\n          content.order = choicePatternTasks.length + 1;\n        });\n        console.log(registerTask);\n        state.userTaskInfo.tasks.push(registerTask);\n        setKey(!key);\n      },\n\n      // タスクのパターン登録状況を更新する。\n      taskPatternUpdate(state, action) {\n        // ここでやることは？\n        // まず引数にタスクの配列インデックス番号が必要\n        // パターンIDの配列を受け取る。\n        // 配列とstateを比較して、なければ登録。Orderは最大値+1。逆に削除されているものは除外。\n        const statePatternIdList = state.userTaskInfo.tasks[action.payload.index].patternInfo.map(content => {\n          return content.patternID;\n        });\n        console.log(\"statePatternIdList\");\n        console.log(statePatternIdList);\n\n        const diff = (olds, nexts) => ({\n          adds: nexts.filter(e => !olds.includes(e)),\n          subs: olds.filter(e => !nexts.includes(e))\n        });\n\n        const result = diff(statePatternIdList, action.payload.newChecked);\n        let updateArray;\n        console.log(result); // stateから削除対象を除外した配列を抽出する。\n\n        if (result.subs.length > 0) {\n          updateArray = state.userTaskInfo.tasks[action.payload.index].patternInfo.filter(function (content) {\n            // futurePatternUpdate(state,);\n            return result.subs.some(sub => sub != content.patternID);\n          });\n        } else {\n          updateArray = state.userTaskInfo.tasks[action.payload.index].patternInfo;\n        }\n\n        console.log(\"1:updateArray\");\n        console.log(updateArray); //\n\n        result.adds.map(add => {\n          let Max = 0; // 追加されたIDが設定されているタスクを抽出する。\n\n          const choicePatternTasks = state.userTaskInfo.tasks.filter(function (task) {\n            return task.patternInfo.some(taskPatternInfo => taskPatternInfo.patternID == add);\n          }); //\n\n          choicePatternTasks.map(task => {\n            // 抽出された各タスクのパターンIDを比較し、最大値を取得する。\n            let content = task.patternInfo.find(info => info.patternID == add);\n            Max < content.patternID ? Max = content.patternID : \"\";\n          });\n          const pushContent = {\n            patternID: add,\n            order: Max + 1\n          };\n          updateArray.push(pushContent);\n          futurePatternUpdate(state, add);\n        });\n        console.log(\"2:updateArray\");\n        console.log(updateArray);\n        state.userTaskInfo.tasks[action.payload.index].patternInfo = updateArray;\n        setKey(!key);\n      },\n\n      // タスクを削除する処理。引数には削除対象タスクのインデックス番号が格納されている。\n      taskDelete(state, action) {\n        // const deleteTask = state.userTaskInfo.tasks.splice(\n        //     action.payload,\n        //     1\n        // );\n        const deleteTask = state.userTaskInfo.tasks.filter(function (content, index) {\n          return index != action.payload;\n        });\n        console.log(deleteTask);\n        state.userTaskInfo.tasks = deleteTask;\n        setKey(!key);\n      },\n\n      // タスクをパターンから除外する処理。引数のオブジェクトにはパターンIDと削除対象タスクの名称が格納されている。\n      taskRemovePattern(state, action) {\n        const index = state.userTaskInfo.tasks.findIndex(content => {\n          return content.detail[\"タスク名\"] == action.payload.detailTitle;\n        });\n        const deletedTask = state.userTaskInfo.tasks[index].patternInfo.filter(function (content) {\n          return content.patternID != action.payload.patternId;\n        });\n        state.userTaskInfo.tasks[index].patternInfo = deletedTask;\n        console.log(deletedTask); // futurePatternUpdate(state);\n\n        setKey(!key);\n      },\n\n      // パターンを追加する処理。引数にはパターン名称が格納されている。\n      patternRegister(state, action) {\n        let MaxId = 0;\n        state.userTaskInfo.pattern.map(patternContent => {\n          patternContent.patternId > MaxId ? MaxId = patternContent.patternId : \"\";\n        });\n        const addPattern = {\n          patternId: MaxId + 1,\n          patternName: action.payload\n        };\n        state.userTaskInfo.pattern.push(addPattern);\n        setKey(!key);\n      },\n\n      // パターンを削除する処理。引数にはパターンIDが格納されている。\n      patternDelete(state, action) {\n        const updatePatternList = state.userTaskInfo.pattern.filter(patternContent => {\n          // console.log(patternContent.patternId);\n          // console.log(action.payload);\n          return patternContent.patternId != action.payload;\n        });\n        console.log(updatePatternList);\n        state.userTaskInfo.pattern = updatePatternList; // タスクとカレンダーに保管されているパターンを全て削除する必要がある\n        // カレンダーは未来分だけ\n        // state.userTaskInfo.tasksに保管されているパターン情報を削除する。\n\n        let updateTaskList = state.userTaskInfo.tasks.map(task => {\n          const updatePatternInfo = task.patternInfo.filter(taskPatternInfo => {\n            return taskPatternInfo.patternID != action.payload;\n          });\n          const updateTask = {\n            detail: task.detail,\n            patternInfo: updatePatternInfo\n          };\n          return updateTask;\n        });\n        console.log(\"after:updateTaskList\");\n        console.log(updateTaskList);\n        state.userTaskInfo.tasks = updateTaskList; // state.userTaskInfo.calendarの未来分に保管されているパターン情報を削除する。\n\n        const today = new Date();\n        const nowYear = today.getFullYear();\n        const nowMonth = today.getMonth() + 1;\n        const nowDate = today.getDate();\n        const keyYears = Object.keys(state.userTaskInfo.calendar);\n\n        const deleteCalendarDate = (year, month, date) => {\n          if (state.userTaskInfo.calendar[parseInt(year)][parseInt(month)][parseInt(date)].PatternId == action.payload) {\n            delete state.userTaskInfo.calendar[parseInt(year)][parseInt(month)][parseInt(date)];\n          }\n        };\n\n        keyYears.map(year => {\n          const keyMonth = Object.keys(state.userTaskInfo.calendar[parseInt(year)]);\n\n          if (parseInt(year) > nowYear) {\n            // 対象が来年以降である場合、削除する。deleteのほうがいい\n            keyMonth.map(month => {\n              const keyDate = Object.keys(state.userTaskInfo.calendar[parseInt(year)][parseInt(month)]);\n              keyDate.map(date => {\n                deleteCalendarDate(year, month, date);\n              });\n            });\n          } else if (parseInt(year) == nowYear) {\n            // 対象が今年である場合\n            keyMonth.map(month => {\n              const keyDate = Object.keys(state.userTaskInfo.calendar[parseInt(year)][parseInt(month)]);\n\n              if (parseInt(month) > nowMonth) {\n                // 来月以降の場合、削除する。deleteのほうがいい\n                console.log(keyDate);\n                keyDate.map(date => {\n                  deleteCalendarDate(year, month, date);\n                });\n              } else if (parseInt(month) == nowMonth) {\n                // 今月の場合\n                keyDate.map(date => {\n                  if (parseInt(date) > nowDate) {\n                    // 明日以降の場合、削除する\n                    deleteCalendarDate(year, month, date);\n                  }\n                });\n              }\n            });\n          }\n        });\n        setKey(!key);\n      },\n\n      // パターン名称を編集する処理。引数にはパターンIDとパターン名称が格納されている。\n      patternNameEdit(state, action) {\n        // IDに合致する要素のインデックス番号を取得\n        const editPatternIndex = state.userTaskInfo.pattern.findIndex(patternContent => patternContent.patternId == action.payload.editPatternId); // 取得したインデックス番号を目印に、引数の新しい名称で更新する。\n\n        state.userTaskInfo.pattern[editPatternIndex].patternName = action.payload.patternName;\n        setKey(!key);\n      }\n\n    }\n  });\n}\n;\nexport const {\n  init,\n  Register,\n  allDelete,\n  taskCheckComplete,\n  calendarPatternRegister,\n  taskDetailRegister,\n  taskRegister,\n  taskPatternUpdate,\n  taskDelete,\n  taskRemovePattern,\n  patternRegister,\n  patternDelete,\n  patternNameEdit\n} = tasksModule().actions; // export default useTasksModule;","map":{"version":3,"sources":["C:/Users/blelm/Desktop/AppCreate/habitPlan/src/modules/tasksModule.tsx"],"names":["createSlice","useState","useRegisterData","initialState","userTaskInfo","calendar","Date","getFullYear","getMonth","getDate","PatternId","tasks","order","detail","flug","pattern","patternId","patternName","patternInfo","patternID","futurePatternUpdate","state","updatePatternId","console","log","Object","keys","today","nowYear","nowMonth","nowDate","choicePatternTasks","filter","task","some","updateTasks","map","taskPattern","keyMonthList","keyYear","parseInt","keyDateList","keyMonth","dateTaskUpdate","keyDate","diff","olds","nexts","adds","e","includes","subs","keyYears","keyMonths","keyDates","result","updateArray","sub","add","push","tasksModule","key","setKey","registerData","name","reducers","init","action","data","payload","Register","allDelete","taskCheckComplete","index","findIndex","calendarPatternRegister","TodayTasks","taskDetailRegister","taskRegister","registerTask","content","length","taskPatternUpdate","statePatternIdList","newChecked","Max","taskPatternInfo","find","info","pushContent","taskDelete","deleteTask","taskRemovePattern","detailTitle","deletedTask","patternRegister","MaxId","patternContent","addPattern","patternDelete","updatePatternList","updateTaskList","updatePatternInfo","updateTask","deleteCalendarDate","year","month","date","patternNameEdit","editPatternIndex","editPatternId","actions"],"mappings":"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","sourcesContent":["import { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\r\nimport { subSeconds } from \"date-fns\";\r\nimport { useState } from \"react\";\r\nimport { useRegisterData } from \"../components/test/firebaseTest/DBFetch\";\r\nimport {\r\n    calendar,\r\n    pattern,\r\n    tasks,\r\n    userTask,\r\n    userTaskInfo,\r\n} from \"./userTasksType\";\r\n\r\ntype State = {\r\n    [key: string]: string;\r\n};\r\n\r\nconst initialState: userTask = {\r\n    userTaskInfo: {\r\n        calendar: {\r\n            [new Date(\"Thu, 22 Oct 2020 02:00:00\").getFullYear()]: {\r\n                [new Date(\"Thu, 22 Oct 2020 02:00:00\").getMonth() + 1]: {\r\n                    [new Date(\"Thu, 22 Oct 2020 02:00:00\").getDate()]: {\r\n                        PatternId: 1,\r\n                        tasks: [\r\n                            {\r\n                                order: 1,\r\n                                detail: {\r\n                                    [\"タスク名\"]: \"タスク名 22 1\",\r\n                                    [\"testDetail1\"]: \"testDetail1 22 1\",\r\n                                    [\"testDetail2\"]: \"testDetail1 22 1\",\r\n                                },\r\n                                flug: false,\r\n                            },\r\n                            {\r\n                                order: 2,\r\n                                detail: {\r\n                                    [\"タスク名\"]: \"タスク名 22 2\",\r\n                                    [\"testDetail1\"]: \"testDetail1 22 2\",\r\n                                    [\"testDetail2\"]: \"testDetail1 22 2\",\r\n                                },\r\n                                flug: false,\r\n                            },\r\n                        ],\r\n                    },\r\n                    [new Date(\"Thu, 23 Oct 2020 02:00:00\").getDate()]: {\r\n                        PatternId: 1,\r\n                        tasks: [\r\n                            {\r\n                                order: 1,\r\n                                detail: {\r\n                                    [\"タスク名\"]: \"タスク名 23 1\",\r\n                                    [\"testDetail1\"]: \"testDetail1 23 1\",\r\n                                    [\"testDetail2\"]: \"testDetail1 23 1\",\r\n                                },\r\n                                flug: false,\r\n                            },\r\n                            {\r\n                                order: 2,\r\n                                detail: {\r\n                                    [\"タスク名\"]: \"タスク名 23 2\",\r\n                                    [\"testDetail1\"]: \"testDetail1 23 2\",\r\n                                    [\"testDetail2\"]: \"testDetail1 23 2\",\r\n                                },\r\n                                flug: false,\r\n                            },\r\n                        ],\r\n                    },\r\n                },\r\n            },\r\n        },\r\n\r\n        pattern: [\r\n            {\r\n                patternId: 1,\r\n                patternName: \"testPattern1\",\r\n            },\r\n            {\r\n                patternId: 2,\r\n                patternName: \"testPattern2\",\r\n            },\r\n        ],\r\n        tasks: [\r\n            {\r\n                detail: {\r\n                    [\"タスク名\"]: \"タスク名 22 1\",\r\n                    [\"defalut\"]: \"defalut\",\r\n                    [\"testDetail1\"]: \"testDetail1 22 1\",\r\n                    [\"testDetail2\"]: \"testDetail1 22 1\",\r\n                },\r\n                patternInfo: [\r\n                    {\r\n                        patternID: 1,\r\n                        order: 1,\r\n                    },\r\n                ],\r\n            },\r\n            {\r\n                detail: {\r\n                    [\"タスク名\"]: \"タスク名 22 2\",\r\n                    [\"defalut\"]: \"defalut\",\r\n                    [\"testDetail1\"]: \"testDetail1 22 2\",\r\n                    [\"testDetail2\"]: \"testDetail1 22 2\",\r\n                },\r\n                patternInfo: [\r\n                    {\r\n                        patternID: 1,\r\n                        order: 2,\r\n                    },\r\n                ],\r\n            },\r\n            {\r\n                detail: {\r\n                    [\"タスク名\"]: \"タスク名 23 1\",\r\n                    [\"defalut\"]: \"defalut\",\r\n                    [\"testDetail1\"]: \"testDetail1 23 1\",\r\n                    [\"testDetail2\"]: \"testDetail1 23 1\",\r\n                },\r\n                patternInfo: [\r\n                    {\r\n                        patternID: 2,\r\n                        order: 1,\r\n                    },\r\n                    {\r\n                        patternID: 1,\r\n                        order: 3,\r\n                    },\r\n                ],\r\n            },\r\n            {\r\n                detail: {\r\n                    [\"タスク名\"]: \"タスク名 23 2\",\r\n                    [\"defalut\"]: \"defalut\",\r\n                    [\"testDetail2\"]: \"testDetail1 23 2\",\r\n                    [\"testDetail1\"]: \"testDetail1 23 2\",\r\n                },\r\n                patternInfo: [\r\n                    {\r\n                        patternID: 2,\r\n                        order: 2,\r\n                    },\r\n                ],\r\n            },\r\n        ],\r\n    },\r\n};\r\n\r\n// const diff = (olds: any[], nexts: any[]) => ({\r\n//     adds: nexts.filter((e) => !olds.includes(e)),\r\n//     subs: olds.filter((e) => !nexts.includes(e)),\r\n// });\r\n\r\n// パターン更新時に未来に設定されているパターンの内容を更新する。\r\n// 更新対象はstate.calendar.tasks\r\n// 年月日が未来であり、かつ、パターンIDが同じものを対象に新しいパターンを登録する。\r\nconst futurePatternUpdate = (state: userTask, updatePatternId: number) => {\r\n    console.log(\"====futurePatternUpdateここから====\");\r\n\r\n    console.log(Object.keys(state.userTaskInfo.calendar));\r\n    const today = new Date();\r\n    const nowYear = today.getFullYear();\r\n    const nowMonth = today.getMonth() + 1;\r\n    const nowDate = today.getDate();\r\n\r\n    const choicePatternTasks = state.userTaskInfo.tasks.filter(function (task) {\r\n        return task.patternInfo.some(\r\n            (task) => task.patternID == updatePatternId\r\n        );\r\n    });\r\n\r\n    // パターンIDに紐付くタスク一覧からカレンダーへの登録情報を抽出する。\r\n    const updateTasks = choicePatternTasks.map((task) => {\r\n        // パターンが複数登録されているタスクへの対応として、選択されているパターンIDに該当する要素だけを抽出する。\r\n        const taskPattern = task.patternInfo.filter(function (patternInfo) {\r\n            return patternInfo.patternID == updatePatternId;\r\n        });\r\n\r\n        // 配列のタスクと抽出したパターン情報を整形して返す。\r\n        return {\r\n            order: taskPattern[0].order,\r\n            detail: task.detail,\r\n            // detail2: task.detail2,\r\n            flug: false,\r\n        };\r\n    });\r\n\r\n    const keyMonthList = (keyYear: string) => {\r\n        return Object.keys(state.userTaskInfo.calendar[parseInt(keyYear)]);\r\n    };\r\n    const keyDateList = (keyYear: string, keyMonth: string) => {\r\n        return Object.keys(\r\n            state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)]\r\n        );\r\n    };\r\n\r\n    const dateTaskUpdate = (\r\n        keyYear: string,\r\n        keyMonth: string,\r\n        keyDate: string\r\n    ) => {\r\n        if (\r\n            state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][\r\n                parseInt(keyDate)\r\n            ].PatternId == updatePatternId\r\n        ) {\r\n            state.userTaskInfo.calendar[parseInt(keyYear)][parseInt(keyMonth)][\r\n                parseInt(keyDate)\r\n            ].tasks = updateTasks;\r\n            console.log(\"===dateTaskUpdate===\");\r\n            console.log(keyYear);\r\n            console.log(keyMonth);\r\n            console.log(keyDate);\r\n            console.log(updateTasks);\r\n        }\r\n    };\r\n\r\n    type calendarPattern = {\r\n        order: number;\r\n        detail: {\r\n            [content: string]: string;\r\n        };\r\n        flug: boolean;\r\n    };\r\n\r\n    const diff = (olds: calendarPattern[], nexts: calendarPattern[]) => ({\r\n        adds: nexts.filter((e) => !olds.includes(e)),\r\n        subs: olds.filter((e) => !nexts.includes(e)),\r\n    });\r\n\r\n    // 登録されている年の連想配列のキーを全て取得\r\n    const keyYears = Object.keys(state.userTaskInfo.calendar);\r\n    keyYears.map((keyYear) => {\r\n        if (parseInt(keyYear) == nowYear) {\r\n            // もし今年だったら、の処理\r\n            // 登録されている月の連想配列のキーを全て取得\r\n            const keyMonths = keyMonthList(keyYear);\r\n\r\n            keyMonths.map((keyMonth) => {\r\n                if (parseInt(keyMonth) == nowMonth) {\r\n                    // もし今月だったら\r\n                    // 登録されている日の連想配列のキーを全て取得\r\n                    const keyDates = keyDateList(keyYear, keyMonth);\r\n                    keyDates.map((keyDate) => {\r\n                        if (parseInt(keyDate) > nowDate) {\r\n                            // もし明日以降だったら登録内容を更新する\r\n                            dateTaskUpdate(keyYear, keyMonth, keyDate);\r\n                        } else if (parseInt(keyDate) == nowDate) {\r\n                            // もし今日だったら、変更分だけ反映する。\r\n                            // 処理未作成\r\n                            if (\r\n                                state.userTaskInfo.calendar[parseInt(keyYear)][\r\n                                    parseInt(keyMonth)\r\n                                ][parseInt(keyDate)].PatternId ==\r\n                                updatePatternId\r\n                            ) {\r\n                                const result = diff(\r\n                                    state.userTaskInfo.calendar[\r\n                                        parseInt(keyYear)\r\n                                    ][parseInt(keyMonth)][parseInt(keyDate)]\r\n                                        .tasks,\r\n                                    updateTasks\r\n                                );\r\n                                const updateArray = state.userTaskInfo.calendar[\r\n                                    parseInt(keyYear)\r\n                                ][parseInt(keyMonth)][\r\n                                    parseInt(keyDate)\r\n                                ].tasks.filter(function (task) {\r\n                                    return result.subs.some(\r\n                                        (sub) => sub != task\r\n                                    );\r\n                                });\r\n\r\n                                result.adds.map((add) => {\r\n                                    updateArray.push(add);\r\n                                });\r\n                                state.userTaskInfo.calendar[parseInt(keyYear)][\r\n                                    parseInt(keyMonth)\r\n                                ][parseInt(keyDate)].tasks = updateArray;\r\n                            }\r\n                        }\r\n                    });\r\n                } else if (parseInt(keyMonth) > nowMonth) {\r\n                    // もし来月以降だったら、すべて更新する。\r\n                    const keyDates = keyDateList(keyYear, keyMonth);\r\n                    keyDates.map((keyDate) => {\r\n                        dateTaskUpdate(keyYear, keyMonth, keyDate);\r\n                    });\r\n                }\r\n            });\r\n        } else if (parseInt(keyYear) > nowYear) {\r\n            // もし来年以降だったら、の処理。全て更新する。\r\n            const keyMonths = keyMonthList(keyYear);\r\n            keyMonths.map((keyMonth) => {\r\n                const keyDates = keyDateList(keyYear, keyMonth);\r\n                keyDates.map((keyDate) => {\r\n                    dateTaskUpdate(keyYear, keyMonth, keyDate);\r\n                });\r\n            });\r\n        }\r\n    });\r\n\r\n    console.log(\"====futurePatternUpdateここまで====\");\r\n};\r\n\r\nexport default function tasksModule() {\r\n    const [key, setKey] = useState(true);\r\n    const registerData = useRegisterData(key);\r\n    registerData();\r\n    return createSlice({\r\n        name: \"tasks\",\r\n        initialState,\r\n        reducers: {\r\n            init(state: userTask, action: PayloadAction<userTaskInfo>) {\r\n                const data = action.payload;\r\n                console.log(\"init data\");\r\n                console.log(data);\r\n                // state = {...data};\r\n                // console.log(\"init state.userTaskInfo 前\");\r\n                // console.log(state.userTaskInfo);\r\n                state.userTaskInfo = data;\r\n                // console.log(\"init state.userTaskInfo 後\");\r\n                // console.log(state.userTaskInfo);\r\n            },\r\n            Register(state: userTask, action: PayloadAction<userTask>) {\r\n                const data = action.payload;\r\n\r\n                state = { ...state, ...data };\r\n                // console.log('state');\r\n                // console.log(state);\r\n            },\r\n            allDelete(state: userTask) {\r\n                state = initialState;\r\n                console.log(\"check allDelete\");\r\n            },\r\n            // DayPlanにてタスクをクリックした際に完了フラグをtrueに変更する処理。引数にて年、月、日、タスクのインデックス番号を受け取っている。\r\n            taskCheckComplete(\r\n                state: userTask,\r\n                action: PayloadAction<number[]>\r\n            ) {\r\n                const index = state.userTaskInfo.calendar[action.payload[0]][\r\n                    action.payload[1]\r\n                ][action.payload[2]].tasks.findIndex(\r\n                    (tasks) => tasks.order == action.payload[3]\r\n                );\r\n                console.log(index);\r\n                state.userTaskInfo.calendar[action.payload[0]][\r\n                    action.payload[1]\r\n                ][action.payload[2]].tasks[index].flug = !state.userTaskInfo\r\n                    .calendar[action.payload[0]][action.payload[1]][\r\n                    action.payload[2]\r\n                ].tasks[index].flug;\r\n                setKey(!key);\r\n                \r\n            },\r\n            // 引数はstateと年、月、日、選択されているパターンIDの4つの数値が格納された配列\r\n            calendarPatternRegister(\r\n                state: userTask,\r\n                action: PayloadAction<number[]>\r\n            ) {\r\n                // stateから選択されているパターンIDが設定されているタスクを抽出する。\r\n                const choicePatternTasks = state.userTaskInfo.tasks.filter(\r\n                    function (task) {\r\n                        return task.patternInfo.some(\r\n                            (task) => task.patternID == action.payload[3]\r\n                        );\r\n                    }\r\n                );\r\n\r\n                // パターンIDに紐付くタスク一覧からカレンダーへの登録情報を抽出する。\r\n                const TodayTasks = choicePatternTasks.map((task) => {\r\n                    // パターンが複数登録されているタスクへの対応として、選択されているパターンIDに該当する要素だけを抽出する。\r\n                    const taskPattern = task.patternInfo.filter(function (\r\n                        patternInfo\r\n                    ) {\r\n                        return patternInfo.patternID == action.payload[3];\r\n                    });\r\n\r\n                    // 配列のタスクと抽出したパターン情報を整形して返す。\r\n                    return {\r\n                        order: taskPattern[0].order,\r\n                        detail: task.detail,\r\n                        // detail2: task.detail2,\r\n                        flug: false,\r\n                    };\r\n                });\r\n\r\n                // ここに年がなかった時の処理を加える\r\n                if (action.payload[0] in state.userTaskInfo.calendar) {\r\n                    // stateのMonthの連想配列に新しい日付の連想配列を追加する。\r\n                    // 追加情報は引数の日とこれまでの処理で作成したカレンダー登録用情報\r\n                    state.userTaskInfo.calendar[action.payload[0]][\r\n                        action.payload[1]\r\n                    ] = {\r\n                        ...state.userTaskInfo.calendar[action.payload[0]][\r\n                            action.payload[1]\r\n                        ],\r\n                        [action.payload[2]]: {\r\n                            PatternId: action.payload[3],\r\n                            tasks: TodayTasks,\r\n                        },\r\n                    };\r\n                } else {\r\n                    // stateのMonthの連想配列に新しい日付の連想配列を追加する。\r\n                    // 追加情報は引数の日とこれまでの処理で作成したカレンダー登録用情報\r\n                    state.userTaskInfo.calendar[action.payload[0]] = {\r\n                        ...state.userTaskInfo.calendar[action.payload[0]],\r\n                        [action.payload[1]]: {\r\n                            [action.payload[2]]: {\r\n                                PatternId: action.payload[3],\r\n                                tasks: TodayTasks,\r\n                            },\r\n                        },\r\n                    };\r\n                }\r\n\r\n                // action.payload[3];\r\n                // console.log(\r\n                //     state.userTaskInfo.calendar[action.payload[0]][\r\n                //         action.payload[1]\r\n                //     ][action.payload[2]]\r\n                // );\r\n                setKey(!key);\r\n            },\r\n            // タスクの詳細を設定する処理。引数のテキスト配列には[入力内容、連想配列のキー、タスクの配列を指定する数字]が格納されている。\r\n            taskDetailRegister(\r\n                state: userTask,\r\n                action: PayloadAction<string[]>\r\n            ) {\r\n                state.userTaskInfo.tasks[parseInt(action.payload[2])].detail = {\r\n                    ...state.userTaskInfo.tasks[parseInt(action.payload[2])]\r\n                        .detail,\r\n                    [action.payload[1]]: action.payload[0],\r\n                };\r\n                setKey(!key);\r\n            },\r\n            // タスクを追加する処理。引数のテキスト配列には[入力内容、連想配列のキー、タスクの配列を指定する数字]が格納されている。\r\n            taskRegister(state: userTask, action: PayloadAction<tasks>) {\r\n                const registerTask = action.payload;\r\n                registerTask.patternInfo.map((content) => {\r\n                    const choicePatternTasks = state.userTaskInfo.tasks.filter(\r\n                        function (task) {\r\n                            return task.patternInfo.some(\r\n                                (task) => task.patternID == content.patternID\r\n                            );\r\n                        }\r\n                    );\r\n                    content.order = choicePatternTasks.length + 1;\r\n                });\r\n                console.log(registerTask);\r\n                state.userTaskInfo.tasks.push(registerTask);\r\n                setKey(!key);\r\n            },\r\n            // タスクのパターン登録状況を更新する。\r\n            taskPatternUpdate(\r\n                state: userTask,\r\n                action: PayloadAction<{\r\n                    newChecked: number[];\r\n                    index: number;\r\n                }>\r\n            ) {\r\n                // ここでやることは？\r\n                // まず引数にタスクの配列インデックス番号が必要\r\n                // パターンIDの配列を受け取る。\r\n                // 配列とstateを比較して、なければ登録。Orderは最大値+1。逆に削除されているものは除外。\r\n\r\n                const statePatternIdList = state.userTaskInfo.tasks[\r\n                    action.payload.index\r\n                ].patternInfo.map((content) => {\r\n                    return content.patternID;\r\n                });\r\n                console.log(\"statePatternIdList\");\r\n                console.log(statePatternIdList);\r\n                const diff = (olds: number[], nexts: number[]) => ({\r\n                    adds: nexts.filter((e) => !olds.includes(e)),\r\n                    subs: olds.filter((e) => !nexts.includes(e)),\r\n                });\r\n                const result = diff(\r\n                    statePatternIdList,\r\n                    action.payload.newChecked\r\n                );\r\n                let updateArray: {\r\n                    patternID: number;\r\n                    order: number;\r\n                }[];\r\n                console.log(result);\r\n\r\n                // stateから削除対象を除外した配列を抽出する。\r\n                if (result.subs.length > 0) {\r\n                    updateArray = state.userTaskInfo.tasks[\r\n                        action.payload.index\r\n                    ].patternInfo.filter(function (content) {\r\n                        // futurePatternUpdate(state,);\r\n                        return result.subs.some(\r\n                            (sub) => sub != content.patternID\r\n                        );\r\n                    });\r\n                } else {\r\n                    updateArray =\r\n                        state.userTaskInfo.tasks[action.payload.index]\r\n                            .patternInfo;\r\n                }\r\n\r\n                console.log(\"1:updateArray\");\r\n                console.log(updateArray);\r\n\r\n                //\r\n                result.adds.map((add) => {\r\n                    let Max: number = 0;\r\n                    // 追加されたIDが設定されているタスクを抽出する。\r\n                    const choicePatternTasks = state.userTaskInfo.tasks.filter(\r\n                        function (task) {\r\n                            return task.patternInfo.some(\r\n                                (taskPatternInfo) =>\r\n                                    taskPatternInfo.patternID == add\r\n                            );\r\n                        }\r\n                    );\r\n                    //\r\n                    choicePatternTasks.map((task) => {\r\n                        // 抽出された各タスクのパターンIDを比較し、最大値を取得する。\r\n                        let content = task.patternInfo.find(\r\n                            (info) => info.patternID == add\r\n                        );\r\n                        Max < content.patternID\r\n                            ? (Max = content.patternID)\r\n                            : \"\";\r\n                    });\r\n\r\n                    const pushContent = { patternID: add, order: Max + 1 };\r\n                    updateArray.push(pushContent);\r\n                    futurePatternUpdate(state, add);\r\n                });\r\n                console.log(\"2:updateArray\");\r\n                console.log(updateArray);\r\n\r\n                state.userTaskInfo.tasks[\r\n                    action.payload.index\r\n                ].patternInfo = updateArray;\r\n                setKey(!key);\r\n            },\r\n            // タスクを削除する処理。引数には削除対象タスクのインデックス番号が格納されている。\r\n            taskDelete(state: userTask, action: PayloadAction<number>) {\r\n                // const deleteTask = state.userTaskInfo.tasks.splice(\r\n                //     action.payload,\r\n                //     1\r\n                // );\r\n                const deleteTask = state.userTaskInfo.tasks.filter(function (\r\n                    content,\r\n                    index\r\n                ) {\r\n                    return index != action.payload;\r\n                });\r\n                console.log(deleteTask);\r\n                state.userTaskInfo.tasks = deleteTask;\r\n                setKey(!key);\r\n            },\r\n            // タスクをパターンから除外する処理。引数のオブジェクトにはパターンIDと削除対象タスクの名称が格納されている。\r\n            taskRemovePattern(\r\n                state: userTask,\r\n                action: PayloadAction<{\r\n                    patternId: number;\r\n                    detailTitle: string;\r\n                }>\r\n            ) {\r\n                const index = state.userTaskInfo.tasks.findIndex((content) => {\r\n                    return (\r\n                        content.detail[\"タスク名\"] == action.payload.detailTitle\r\n                    );\r\n                });\r\n                const deletedTask = state.userTaskInfo.tasks[\r\n                    index\r\n                ].patternInfo.filter(function (content) {\r\n                    return content.patternID != action.payload.patternId;\r\n                });\r\n                state.userTaskInfo.tasks[index].patternInfo = deletedTask;\r\n                console.log(deletedTask);\r\n                // futurePatternUpdate(state);\r\n                setKey(!key);\r\n            },\r\n            // パターンを追加する処理。引数にはパターン名称が格納されている。\r\n            patternRegister(state: userTask, action: PayloadAction<string>) {\r\n                let MaxId: number = 0;\r\n                state.userTaskInfo.pattern.map((patternContent) => {\r\n                    patternContent.patternId > MaxId\r\n                        ? (MaxId = patternContent.patternId)\r\n                        : \"\";\r\n                });\r\n                const addPattern = {\r\n                    patternId: MaxId + 1,\r\n                    patternName: action.payload,\r\n                };\r\n                state.userTaskInfo.pattern.push(addPattern);\r\n                setKey(!key);\r\n            },\r\n            // パターンを削除する処理。引数にはパターンIDが格納されている。\r\n            patternDelete(state: userTask, action: PayloadAction<number>) {\r\n                const updatePatternList = state.userTaskInfo.pattern.filter(\r\n                    (patternContent) => {\r\n                        // console.log(patternContent.patternId);\r\n                        // console.log(action.payload);\r\n                        return patternContent.patternId != action.payload;\r\n                    }\r\n                );\r\n\r\n                console.log(updatePatternList);\r\n                state.userTaskInfo.pattern = updatePatternList;\r\n\r\n                // タスクとカレンダーに保管されているパターンを全て削除する必要がある\r\n                // カレンダーは未来分だけ\r\n\r\n                // state.userTaskInfo.tasksに保管されているパターン情報を削除する。\r\n                let updateTaskList = state.userTaskInfo.tasks.map((task) => {\r\n                    const updatePatternInfo = task.patternInfo.filter(\r\n                        (taskPatternInfo) => {\r\n                            return taskPatternInfo.patternID != action.payload;\r\n                        }\r\n                    );\r\n                    const updateTask: {\r\n                        detail: {\r\n                            [content: string]: string;\r\n                        };\r\n                        patternInfo: {\r\n                            patternID: number;\r\n                            order: number;\r\n                        }[];\r\n                    } = { detail: task.detail, patternInfo: updatePatternInfo };\r\n                    return updateTask;\r\n                });\r\n                console.log(\"after:updateTaskList\");\r\n                console.log(updateTaskList);\r\n                state.userTaskInfo.tasks = updateTaskList;\r\n\r\n                // state.userTaskInfo.calendarの未来分に保管されているパターン情報を削除する。\r\n                const today = new Date();\r\n                const nowYear = today.getFullYear();\r\n                const nowMonth = today.getMonth() + 1;\r\n                const nowDate = today.getDate();\r\n                const keyYears = Object.keys(state.userTaskInfo.calendar);\r\n                const deleteCalendarDate = (\r\n                    year: string,\r\n                    month: string,\r\n                    date: string\r\n                ) => {\r\n                    if (\r\n                        state.userTaskInfo.calendar[parseInt(year)][\r\n                            parseInt(month)\r\n                        ][parseInt(date)].PatternId == action.payload\r\n                    ) {\r\n                        delete state.userTaskInfo.calendar[parseInt(year)][\r\n                            parseInt(month)\r\n                        ][parseInt(date)];\r\n                    }\r\n                };\r\n                keyYears.map((year) => {\r\n                    const keyMonth = Object.keys(\r\n                        state.userTaskInfo.calendar[parseInt(year)]\r\n                    );\r\n                    if (parseInt(year) > nowYear) {\r\n                        // 対象が来年以降である場合、削除する。deleteのほうがいい\r\n                        keyMonth.map((month) => {\r\n                            const keyDate = Object.keys(\r\n                                state.userTaskInfo.calendar[parseInt(year)][\r\n                                    parseInt(month)\r\n                                ]\r\n                            );\r\n                            keyDate.map((date) => {\r\n                                deleteCalendarDate(year, month, date);\r\n                            });\r\n                        });\r\n                    } else if (parseInt(year) == nowYear) {\r\n                        // 対象が今年である場合\r\n                        keyMonth.map((month) => {\r\n                            const keyDate = Object.keys(\r\n                                state.userTaskInfo.calendar[parseInt(year)][\r\n                                    parseInt(month)\r\n                                ]\r\n                            );\r\n                            if (parseInt(month) > nowMonth) {\r\n                                // 来月以降の場合、削除する。deleteのほうがいい\r\n                                console.log(keyDate);\r\n                                keyDate.map((date) => {\r\n                                    deleteCalendarDate(year, month, date);\r\n                                });\r\n                            } else if (parseInt(month) == nowMonth) {\r\n                                // 今月の場合\r\n                                keyDate.map((date) => {\r\n                                    if (parseInt(date) > nowDate) {\r\n                                        // 明日以降の場合、削除する\r\n                                        deleteCalendarDate(year, month, date);\r\n                                    }\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n                setKey(!key);\r\n            },\r\n            // パターン名称を編集する処理。引数にはパターンIDとパターン名称が格納されている。\r\n            patternNameEdit(\r\n                state: userTask,\r\n                action: PayloadAction<{\r\n                    editPatternId: number;\r\n                    patternName: string;\r\n                }>\r\n            ) {\r\n                // IDに合致する要素のインデックス番号を取得\r\n                const editPatternIndex = state.userTaskInfo.pattern.findIndex(\r\n                    (patternContent) =>\r\n                        patternContent.patternId == action.payload.editPatternId\r\n                );\r\n                // 取得したインデックス番号を目印に、引数の新しい名称で更新する。\r\n                state.userTaskInfo.pattern[editPatternIndex].patternName =\r\n                    action.payload.patternName;\r\n                setKey(!key);\r\n            },\r\n        },\r\n    });\r\n};\r\n\r\nexport const {\r\n    init,\r\n    Register,\r\n    allDelete,\r\n    taskCheckComplete,\r\n    calendarPatternRegister,\r\n    taskDetailRegister,\r\n    taskRegister,\r\n    taskPatternUpdate,\r\n    taskDelete,\r\n    taskRemovePattern,\r\n    patternRegister,\r\n    patternDelete,\r\n    patternNameEdit,\r\n} = tasksModule().actions;\r\n\r\n// export default useTasksModule;\r\n"]},"metadata":{},"sourceType":"module"}