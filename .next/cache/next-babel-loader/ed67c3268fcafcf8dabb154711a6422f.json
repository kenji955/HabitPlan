{"ast":null,"code":"// データベースへの接続\n// import firebase from \"firebase/app\";\n// 認証周りやDB周りで必要なためimportしておく\nimport \"firebase/auth\";\nimport \"firebase/database\";\nimport { useMemo, useState, useEffect, useCallback } from \"react\";\nimport { useSelector } from \"react-redux\";\nimport { firebase } from \"./firebaseTest\";\n\n// const useReduxFetch = () => {\n//     const dispatch = useDispatch();\n//     return dispatch;\n// };\n// カスタムフックにしておく\nconst useDatabase = () => {\n  // const useDatabase = () => {\n  const {\n    userId\n  } = useSelector(state => state.user); // const dispatch = useDispatch();\n  // const [check, setCheck] = useState(false);\n  // const [userIdCheck, setuserIdCheck] = useState('');\n  // if (userId != '' && userId != userIdCheck){\n  //     console.log('userId');\n  //     console.log(userId);\n  //     console.log('check');\n  //     console.log(check);\n  //     console.log('userIdCheck');\n  //     console.log(userIdCheck);\n  //     setuserIdCheck(userId);\n  //     setCheck(!check);\n  // }\n  // 同じパスでは毎回同じ結果が得られるのでmemo化しておく\n  // return useMemo(() => firebase.database().ref(\"/sample\"), []);\n  // const authUser = firebase.auth().currentUser;\n  // if (!!uid) {\n  //     if (userId == \"\") {\n  //         dispatch(login(uid.uid));\n  //         setCheck(\"check\");\n  //         // console.log(\"check\");\n  //     }\n  //     // console.log(\"DBF 1 userId\");\n  //     // console.log(userId);\n  //     return useMemo(() => firebase.database().ref(\"/users/\" + userId), [\n  //         userId,\n  //     ]);\n  // } else {\n  // ここが原因。ここでuserId取得後にrefを更新できればいい\n\n  console.log(\"DBF 2 userId\");\n  console.log(userId);\n  return useMemo(() => firebase.database().ref(\"/users/\" + userId), [userId]); // return useMemo(() => firebase.database().ref(\"/users/\" + authUser.uid), []);\n  // }\n}; //   データを取得する\n// hooksを使いたいのでカスタムhooksにしておく\n\n\nconst useFetchData = ref => {\n  const {\n    0: data,\n    1: setData\n  } = useState();\n  const {\n    userId\n  } = useSelector(state => state.user);\n  useEffect(() => {\n    if (!!userId) {\n      // イベントリスナーを追加するにはonを使う\n      ref.on(\"value\", snapshot => {\n        // パスに対する全データを含むsnapshotが渡される\n        // ない場合はnullが返るので存在をチェックしておく\n        if (snapshot === null || snapshot === void 0 ? void 0 : snapshot.val()) {\n          setData(snapshot.val());\n          console.log(\"DBF data\");\n          console.log(data);\n        }\n      });\n      console.log(\"DBFetch data==========\");\n      console.log(data);\n      return () => {\n        ref.off();\n      }; // refの変更に応じて再取得する\n      //   指定したパスのデータに対する更新をすべて検知するにはvalueを指定すれば良い。\n    }\n  }, [ref]); // データを返却する\n\n  return {\n    data\n  };\n}; // 実際に呼び出す際はこちらを使う\n\n\nconst useFetchAllData = () => {\n  // refを取得して\n  const ref = useDatabase();\n  console.log('ref');\n  console.log(ref); // ref渡してデータを取得する\n\n  return useFetchData(ref);\n}; // 登録処理\n// この登録はsetに渡した値での登録となる。\n// つまり、既存のデータも含めて渡してあげないと登録済みのデータが消える。\n\n\nconst useSetDocument = ref => {\n  const updateDocument = useCallback(document => {\n    // refについては前回の記事参照\n    // setに登録したいデータを渡してあげれば登録できる\n    ref.set(document);\n  }, [ref]);\n  return updateDocument;\n};\n\nconst useRegisterData = () => {\n  // 前回作ったuseDatabase()を使いref取得\n  const {\n    userId\n  } = useSelector(state => state.user);\n  const ref = firebase.database().ref(\"/users/\" + userId + \"/tasks\");\n  const setDocument = useSetDocument(ref); // 登録済みのデータを全部取得する\n\n  const {\n    data: registeredData\n  } = useFetchAllData(); // データを登録する関数を返却する\n  // 可能であればここの処理はそのままにして、引数でsteteを更新する処理を先に行いたい\n\n  const registerData = useCallback(registerData => {\n    // () => {\n    // console.log(userTaskInfo);\n    // ここでReduxに保管しているstateを更新する？\n    // dispatch(Register({ ...registerData }));\n    // 既存のデータと登録するkey-valueを合わせて登録関数に渡す\n    setDocument([...registeredData.tasks, registerData]); // setDocument(userTaskInfo.tasks);\n  }, [setDocument, registeredData]); // 返した関数を利用することで、登録済みデータ全て+登録したいデータをDBに保管できる\n\n  return registerData;\n}; // 更新処理\n\n\nconst useUpdateDocument = ref => {\n  // ref.updateがObjectを受け取るので、Objectを引数に取る関数を定義\n  const updateDocument = useCallback(document => ref.update(document), [ref]);\n  return updateDocument;\n};\n\nconst useUpdateData = () => {\n  // setの時と同じくrefを取得して、\n  const ref = useDatabase(); // 関数呼び出して\n\n  const updateDocument = useUpdateDocument(ref); // 更新処理を作成する\n\n  const updateData = useCallback(registerData => {\n    updateDocument(registerData);\n  }, [updateDocument]);\n  return updateData;\n}; // 削除処理\n\n\nconst useRemoveDocument = ref => {\n  // 特に引数が必要ないのでただ呼び出すのみ\n  const deleteDocument = useCallback(document => ref.child(document).remove(), [ref]);\n  return deleteDocument;\n}; // set、updateと同じなので割愛\n\n\nconst useDelteData = () => {\n  const ref = useDatabase();\n  const removeDocument = useRemoveDocument(ref);\n  const deleteData = useCallback(deleteData => removeDocument(deleteData), [removeDocument]);\n  return deleteData;\n};\n\nexport { useDatabase, useFetchAllData, useRegisterData, useUpdateData, useDelteData };","map":null,"metadata":{},"sourceType":"module"}